{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pdag</code> \u2014 Parameter Directed Acyclic Graph","text":"<p>Warning</p> <p>This package is under development. Many features are already implemented, but expect some breaking changes in the future.</p> <p>Documentation: https://shunichironomura.github.io/pdag/</p> <p>Source code: https://github.com/shunichironomura/pdag</p> <p><code>pdag</code> is a Python package that helps you create and execute a directed acyclic graph (DAG) of parameters and their relationships. Its features include:</p> <ul> <li>You can define parameters and their dependencies with a Python's class-based syntax and annotations.</li> <li>You can import another model into your model, allowing you to create a hierarchy of models and reuse them.</li> <li>You can use the <code>pdag watch</code> command to watch the graph representation of your model while you are creating it.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pdag\n</code></pre> <p>or any package manager that supports Python packages.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>Here is a simple example of how to use <code>pdag</code> to create a model that squares a number:</p> <pre><code>from typing import Annotated\nimport pdag\n\nclass SquareModel(pdag.Model):\n    \"\"\"Square model that squares a number.\"\"\"\n\n    # x is a real number parameter and is the input to the model\n    x = pdag.RealParameter(\"x\")\n\n    # y is a real number parameter and is the output of the model\n    y = pdag.RealParameter(\"y\")\n\n    # The relationship is defined as a static method\n    # with the @pdag.relationship decorator\n    @pdag.relationship\n    @staticmethod\n    def square(\n      # The annotation `x.ref()` indicates that the value of `x` will be provided\n      # as the value of the `x_arg` parameter when the model is executed.\n      # Note that we use `x_arg` as the name of the argument for documentation purposes,\n      # but in practice, you can just use `x` as the name of the argument.\n      x_arg: Annotated[float, x.ref()],\n\n      # The annotation `y.ref()` indicates that the return value of the method\n      # will be assigned to the `y` parameter when the model is executed.\n    ) -&gt; Annotated[float, y.ref()]:\n        return x_arg**2\n</code></pre> <p>This <code>SquareModel</code> is a static model with input <code>x</code> and output <code>y</code>. Here is the graph representation of the model:</p> <p></p> <p>You can test it by running the following command in the virtual environment where you installed <code>pdag</code>:</p> <pre><code>pdag watch pdag.examples:SquareModel square.png\n</code></pre> <p>To execute the model for a specific value of <code>x</code>, execute the following code:</p> <pre><code>core_model = SquareModel.to_core_model()\nexec_model = pdag.create_exec_model_from_core_model(core_model)\nresults = pdag.execute_exec_model(\n    exec_model,\n    inputs={\n        # `()` indicates the root model, and `\"x\"` is the name of the parameter.\n        pdag.StaticParameterId((), \"x\"): 2.0,\n    },\n)\n\nprint(results)\n# {\n#   StaticParameterId(model_path=(), name='x'): 2.0,\n#   StaticParameterId(model_path=(), name='y'): 4.0,\n# }\n</code></pre>"},{"location":"#parameter-and-collection-types","title":"Parameter and collection types","text":"<p><code>pdag</code> supports the following parameter types:</p> <ul> <li><code>pdag.RealParameter</code>: A real number parameter.</li> <li><code>pdag.BooleanParameter</code>: A boolean parameter.</li> <li><code>pdag.CategoricalParameter</code>: A categorical parameter.</li> </ul> <p>and the following parameter collection types:</p> <ul> <li><code>pdag.Array</code>: An array of <code>pdag</code> parameters.</li> <li><code>pdag.Mapping</code>: A dictionary of <code>pdag</code> parameters.</li> </ul> <p>Here is an example of how to use these parameter types and collections:</p> <pre><code>from typing import Annotated\nimport numpy as np\nimport pdag\n\nclass ModelWithVariousTypes(pdag.Model):\n    \"\"\"Model that uses different parameter types and collections.\"\"\"\n\n    # x is a real number parameter\n    x = pdag.RealParameter(\"x\")\n\n    # y is a boolean parameter\n    y = pdag.BooleanParameter(\"y\")\n\n    # z is a categorical parameter with three possible values\n    z = pdag.CategoricalParameter(\"z\", (\"a\", \"b\", \"c\"))\n\n    # a is an array of real number parameters with two elements\n    # Each parameter's name is automatically generated as \"a[0]\" and \"a[1]\"\n    a = pdag.Array(\"a\", np.array([pdag.RealParameter(...) for _ in range(2)]))\n\n    # m is a dictionary of real number parameters\n    # Each parameter's name is automatically generated as \"m[a]\", \"m[b]\", and \"m[c]\"\n    m = pdag.Mapping(\"m\", {k: pdag.RealParameter(...) for k in [\"a\", \"b\", \"c\"]})\n\n    @pdag.relationship\n    @staticmethod\n    def my_relationship(\n        y_arg: Annotated[bool, y.ref()],\n        z_arg: Annotated[str, z.ref()],\n        a_arg: Annotated[list[float], a.ref()],\n        m_arg: Annotated[Mapping[str, float], m.ref()],\n    ) -&gt; Annotated[float, x.ref()]:\n        if y_arg:\n            return m_arg[z_arg] * a_arg[1] + a_arg[0]\n        else:\n            return 0.0\n</code></pre>"},{"location":"#define-relationships-in-a-for-loop","title":"Define relationships in a for loop","text":"<p><code>pdag</code> allows you to define relationships in a for loop. This is useful, for example, when you want to define a relationship for each element of a mapping.</p> <p>In the following example, we define a <code>EachSquaredModel</code> that calculates the square of each element of a mapping <code>m</code>:</p> <pre><code>from typing import Annotated\nimport numpy as np\nimport pdag\n\nclass EachSquaredModel(pdag.Model):\n    \"\"\"EachSquaredModel model that uses a mapping of parameters.\"\"\"\n\n    m = pdag.Mapping(\"m\", {k: pdag.RealParameter(...) for k in (\"a\", \"b\", \"c\")})\n    m_squared = pdag.Mapping(\"m_squared\", {k: pdag.RealParameter(...) for k in (\"a\", \"b\", \"c\")})\n\n    for k in (\"a\", \"b\", \"c\"):\n        # You need to provide the identifier to distinguish each relationship\n        @pdag.relationship(identifier=k)\n        @staticmethod\n        def square(\n            # The annotation `m.ref(k)` indicates that the value of `m[k]` will be provided\n            # when the model is executed.\n            m_arg: Annotated[float, m.ref(k)],\n\n            # The annotation `m_squared.ref(k)` indicates that the return value of the method\n            # will be assigned to `m_squared[k]` when the model is executed.\n        ) -&gt; Annotated[float, m_squared.ref(k)]:\n            return m_arg**2\n</code></pre>"},{"location":"#dynamic-models","title":"Dynamic models","text":"<p><code>pdag</code> supports dynamic models, where you can define time-series parameters and dynamic relationships between them.</p> <p>In the following example, we define a <code>DiamondMdpModel</code> that simulates a Markov Decision Process (MDP) with a diamond-shaped state space:</p> <pre><code>from typing import Annotated, Literal\n\nimport pdag\n\n\nclass DiamondMdpModel(pdag.Model):\n    \"\"\"Diamond MDP model.\"\"\"\n\n    # The policy parameter is the policy of the agent,\n    # and it is a categorical parameter with two possible values.\n    # It is NOT a time-series parameter.\n    policy = pdag.CategoricalParameter(\"policy\", categories=(\"left\", \"right\"))\n\n    # The location parameter is the state of the MDP.\n    # You need to provide the `is_time_series=True` argument\n    # to indicate that this parameter is a time-series parameter.\n    location = pdag.CategoricalParameter(\n        \"location\",\n        categories=(\"start\", \"left\", \"right\", \"end\"),\n        is_time_series=True\n    )\n\n    # The action parameter is the action taken by the agent,\n    # and it is also a time-series parameter.\n    action = pdag.CategoricalParameter(\n        \"action\",\n        categories=(\"go_left\", \"go_right\", \"move_forward\", \"none\"),\n        is_time_series=True,\n    )\n\n    # The reward parameter is the reward received by the agent,\n    # and it is also a time-series parameter.\n    reward = pdag.RealParameter(\"reward\", is_time_series=True)\n\n    # The cumulative_reward parameter is the cumulative reward received by the agent,\n    # and it is NOT a time-series parameter.\n    cumulative_reward = pdag.RealParameter(\"cumulative_reward\")\n\n    # For relationsihps that should be calculated at each time step,\n    # you need to provide the `at_each_time_step=True` argument\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def action_selection(\n        *,\n        # The value of `policy` is provided as the value of the `policy` parameter\n        policy: Annotated[Literal[\"left\", \"right\"], policy.ref()],\n\n        # The value of `location` at the current time step is provided as the value of the `location` parameter\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n\n        # The return value of the method is assigned to the `action` parameter\n        # at the current time step.\n    ) -&gt; Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()]:\n        match location, policy:\n            case \"start\", \"left\":\n                return \"go_left\"\n            case \"start\", \"right\":\n                return \"go_right\"\n            case \"left\", \"left\":\n                return \"move_forward\"\n            case \"left\", \"right\":\n                return \"go_right\"\n            case \"right\", \"right\":\n                return \"move_forward\"\n            case \"right\", \"left\":\n                return \"go_left\"\n            case \"end\", _:\n                return \"none\"\n\n        msg = f\"Invalid policy and location combination: {policy=}, {location=}\"\n        raise ValueError(msg)\n\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def state_transition(\n        *,\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n        action: Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()],\n\n        # By providing `next=True`, you can indicate that the return value of the method\n        # will be assigned to the `location` parameter at the next time step.\n    ) -&gt; Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref(next=True)]:\n        match location, action:\n            case \"start\", \"go_left\":\n                return \"left\"\n            case \"start\", \"go_right\":\n                return \"right\"\n            case \"start\", \"move_forward\":\n                return \"start\"\n            case \"left\", \"move_forward\":\n                return \"end\"\n            case \"left\", \"go_left\":\n                return \"left\"\n            case \"left\", \"go_right\":\n                return \"right\"\n            case \"right\", \"move_forward\":\n                return \"end\"\n            case \"right\", \"go_left\":\n                return \"left\"\n            case \"right\", \"go_right\":\n                return \"right\"\n            case _, \"none\":\n                return location\n            case \"end\", _:\n                return \"end\"\n\n        msg = f\"Invalid location and action combination: {location=}, {action=}\"\n        raise ValueError(msg)\n\n    @pdag.relationship\n    @staticmethod\n    def initial_reward(\n      # By providing `initial=True`, you can indicate that the return value of the method\n      # will be assigned to the `reward` parameter at the initial time step.\n    ) -&gt; Annotated[float, reward.ref(initial=True)]:\n        return 0.0\n\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def reward_function(\n        *,\n        previous_location: Annotated[\n            Literal[\"start\", \"left\", \"right\", \"end\"],\n            # `previous=True` indicates that the value of the `location` parameter\n            # at the previous time step will be provided as the value of the `previous_location` parameter.\n            location.ref(previous=True),\n        ],\n        action: Annotated[\n            Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"],\n            # `previous=True` indicates that the value of the `action` parameter\n            # at the previous time step will be provided as the value of the `action` parameter.\n            action.ref(previous=True),\n        ],\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n    ) -&gt; Annotated[float, reward.ref()]:\n        if previous_location != \"end\" and location == \"end\":\n            return 1.0\n        return 0.0\n\n    @pdag.relationship\n    @staticmethod\n    def cumulative_reward_calculation(\n        *,\n        # `all_time_steps=True` indicates that the value of the `reward` parameter\n        # at all time steps will be provided as the value of the `reward` parameter.\n        reward: Annotated[list[float], reward.ref(all_time_steps=True)],\n    ) -&gt; Annotated[float, cumulative_reward.ref()]:\n        return sum(reward)\n</code></pre>"},{"location":"#importing-models","title":"Importing models","text":"<p><code>pdag</code> allows you to import another model into your model.</p> <p>In the following example, we define a <code>SquareModel</code> that squares a number and a <code>PolynomialModel</code> that uses the <code>SquareModel</code> to calculate the square term of a polynomial:</p> <pre><code>from typing import Annotated\nimport pdag\n\nclass SquareModel(pdag.Model):\n    \"\"\"Square model that squares a number.\"\"\"\n\n    x = pdag.RealParameter(\"x\")\n    y = pdag.RealParameter(\"y\")\n\n    @pdag.relationship\n    @staticmethod\n    def square(\n      x_arg: Annotated[float, x.ref()],\n    ) -&gt; Annotated[float, y.ref()]:\n        return x_arg**2\n\nclass PolynomialModel(pdag.Model):\n    \"\"\"Polynomial model that calculates y = a[0] + a[1] * x + a[2] * x^2.\"\"\"\n\n    a = pdag.Array(\"a\", np.array([pdag.RealParameter(...) for _ in range(3)]))\n    x = pdag.RealParameter(\"x\")\n    x_squared = pdag.RealParameter(\"x_squared\")\n    y = pdag.RealParameter(\"y\")\n\n    # Import the SquareModel into this model\n    calc_square_term = SquareModel.to_relationship(\n        \"calc_square_term\",\n        # Map the parameters of the SquareModel to the parameters of this model\n        # for inputs and outputs\n        inputs={SquareModel.x.ref(): x.ref()},\n        outputs={SquareModel.y.ref(): x_squared.ref()},\n    )\n\n    @pdag.relationship\n    @staticmethod\n    def polynomial(\n        *,\n        a: Annotated[list[float], a.ref()],\n        x: Annotated[float, x.ref()],\n        x_squared: Annotated[float, x_squared.ref()],\n    ) -&gt; Annotated[float, y.ref()]:\n        return a[0] + a[1] * x + a[2] * x_squared\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>Run tests with:</p> <pre><code>uv run pytest tests\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pdag<ul> <li>examples</li> </ul> </li> </ul>"},{"location":"reference/pdag/","title":"pdag","text":""},{"location":"reference/pdag/#pdag","title":"pdag","text":"<p>A Python package that helps you create and execute a directed acyclic graph (DAG) of parameters and their relationships.</p> MODULE DESCRIPTION <code>examples</code> <p>Examples module that contains example models.</p> CLASS DESCRIPTION <code>Array</code> <p>A collection of parameters or relationships that can be indexed by a tuple of integers.</p> <code>ArrayRef</code> <p>Represents a reference to an array in a model.</p> <code>BooleanParameter</code> <code>CategoricalParameter</code> <code>CollectionABC</code> <code>CollectionRef</code> <p>Represents a reference to a collection in a model.</p> <code>CoreModel</code> <code>ExecInfo</code> <p>Represents the information available during the execution of a model.</p> <code>FunctionRelationship</code> <code>Mapping</code> <p>A collection of parameters or relationships that can be indexed by a string or tuple of strings.</p> <code>MappingRef</code> <p>Represents a reference to a mapping in a model.</p> <code>ParameterABC</code> <p>Abstract base class for all parameters.</p> <code>ParameterRef</code> <p>Represents a reference to a parameter in a model.</p> <code>RealParameter</code> <code>ReferenceABC</code> <p>Represents a reference to a parameter or collection in a model.</p> <code>RelationshipABC</code> <code>SubModelRelationship</code> <code>ExecutionModel</code> <code>StaticParameterId</code> <code>StaticRelationshipId</code> <code>TimeSeriesParameterId</code> <code>TimeSeriesRelationshipId</code> <code>Model</code> FUNCTION DESCRIPTION <code>create_exec_model_from_core_model</code> <code>execute_exec_model</code> <code>distance_constrained_sampling</code> <code>results_to_df</code> <code>run_experiments</code> <code>sample_parameter_values</code> <code>export_dot</code> <code>relationship</code> <p>Decorate a function to mark it as a relationship.</p> ATTRIBUTE DESCRIPTION <code>NodeId</code> <p> TYPE: <code>TypeAlias</code> </p> <code>ParameterId</code> <p> TYPE: <code>TypeAlias</code> </p> <code>RelationshipId</code> <p> TYPE: <code>TypeAlias</code> </p>"},{"location":"reference/pdag/#pdag.Array","title":"Array  <code>dataclass</code>","text":"<pre><code>Array(name: str, array: NDArray[T])\n</code></pre> <p>               Bases: <code>CollectionABC[tuple[int, ...], T]</code></p> <p>A collection of parameters or relationships that can be indexed by a tuple of integers.</p> METHOD DESCRIPTION <code>__post_init__</code> <code>__getitem__</code> <code>items</code> <code>ref</code> <p>Create a reference to the array.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>array</code> <p> TYPE: <code>NDArray[T]</code> </p> <code>shape</code> <p> TYPE: <code>tuple[int, ...]</code> </p>"},{"location":"reference/pdag/#pdag.Array.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'array'\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.array","title":"array  <code>instance-attribute</code>","text":"<pre><code>array: NDArray[T]\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    super().__post_init__()\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: tuple[int, ...]) -&gt; T\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def __getitem__(self, key: tuple[int, ...]) -&gt; T:\n    return self.array[key]  # type: ignore[no-any-return]\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.items","title":"items","text":"<pre><code>items() -&gt; Iterable[tuple[tuple[int, ...], T]]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[tuple[int, ...], T]]:\n    yield from np.ndenumerate(self.array)\n</code></pre>"},{"location":"reference/pdag/#pdag.Array.ref","title":"ref","text":"<pre><code>ref(\n    key: tuple[int, ...] | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; ArrayRef\n</code></pre> <p>Create a reference to the array.</p> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def ref(\n    self,\n    key: tuple[int, ...] | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,  # noqa: A002\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; ArrayRef:\n    \"\"\"Create a reference to the array.\"\"\"\n    return ArrayRef(\n        name=self.name,\n        key=key,\n        previous=previous,\n        next=next,\n        initial=initial,\n        all_time_steps=all_time_steps,\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.ArrayRef","title":"ArrayRef  <code>dataclass</code>","text":"<pre><code>ArrayRef(\n    name: str,\n    key: K | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n)\n</code></pre> <p>               Bases: <code>CollectionRef[tuple[int, ...]]</code></p> <p>Represents a reference to an array in a model.</p>"},{"location":"reference/pdag/#pdag.BooleanParameter","title":"BooleanParameter  <code>dataclass</code>","text":"<pre><code>BooleanParameter(\n    _name: str | EllipsisType,\n    *,\n    is_time_series: bool = False,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>ParameterABC[bool]</code></p> METHOD DESCRIPTION <code>get_type_hint</code> <code>from_unit_interval</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pdag/#pdag.BooleanParameter.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'boolean'\n</code></pre>"},{"location":"reference/pdag/#pdag.BooleanParameter.get_type_hint","title":"get_type_hint","text":"<pre><code>get_type_hint() -&gt; str\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def get_type_hint(self) -&gt; str:\n    return \"bool\"\n</code></pre>"},{"location":"reference/pdag/#pdag.BooleanParameter.from_unit_interval","title":"from_unit_interval","text":"<pre><code>from_unit_interval(value: float) -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def from_unit_interval(self, value: float) -&gt; bool:\n    return value &gt;= 0.5  # noqa: PLR2004\n</code></pre>"},{"location":"reference/pdag/#pdag.CategoricalParameter","title":"CategoricalParameter  <code>dataclass</code>","text":"<pre><code>CategoricalParameter(\n    _name: str | EllipsisType,\n    categories: tuple[T, ...],\n    *,\n    is_time_series: bool = False,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>ParameterABC[T]</code></p> METHOD DESCRIPTION <code>get_type_hint</code> <code>from_unit_interval</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>categories</code> <p> TYPE: <code>tuple[T, ...]</code> </p>"},{"location":"reference/pdag/#pdag.CategoricalParameter.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'categorical'\n</code></pre>"},{"location":"reference/pdag/#pdag.CategoricalParameter.categories","title":"categories  <code>instance-attribute</code>","text":"<pre><code>categories: tuple[T, ...]\n</code></pre>"},{"location":"reference/pdag/#pdag.CategoricalParameter.get_type_hint","title":"get_type_hint","text":"<pre><code>get_type_hint() -&gt; str\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def get_type_hint(self) -&gt; str:\n    return f\"Literal[{', '.join(self._to_type_hint(category) for category in self.categories)}]\"\n</code></pre>"},{"location":"reference/pdag/#pdag.CategoricalParameter.from_unit_interval","title":"from_unit_interval","text":"<pre><code>from_unit_interval(value: float) -&gt; T\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def from_unit_interval(self, value: float) -&gt; T:\n    return self.categories[int(value * len(self.categories))]\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC","title":"CollectionABC  <code>dataclass</code>","text":"<pre><code>CollectionABC(name: str)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>InitArgsRecorder</code></p> METHOD DESCRIPTION <code>__post_init__</code> <p>Set the item type based on the first element in the collection and name the elements.</p> <code>__getitem__</code> <code>items</code> <code>values</code> <code>keys</code> <code>is_hydrated</code> <code>name_elements</code> <code>is_time_series</code> <code>ref</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>item_type</code> <p> TYPE: <code>Literal['parameter', 'relationship']</code> </p>"},{"location":"reference/pdag/#pdag.CollectionABC.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'collection'\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.item_type","title":"item_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>item_type: Literal[\"parameter\", \"relationship\"] = field(\n    init=False\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Set the item type based on the first element in the collection and name the elements.</p> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Set the item type based on the first element in the collection and name the elements.\"\"\"\n    for element in self.values():\n        if isinstance(element, ParameterABC):\n            self.item_type = \"parameter\"\n            break\n        if isinstance(element, RelationshipABC):\n            self.item_type = \"relationship\"\n            break\n        msg = \"Collection must contain only parameters or relationships.\"\n        raise TypeError(msg)\n    self.name_elements()\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.__getitem__","title":"__getitem__  <code>abstractmethod</code>","text":"<pre><code>__getitem__(key: K) -&gt; T\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>@abstractmethod\ndef __getitem__(self, key: K) -&gt; T:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.items","title":"items  <code>abstractmethod</code>","text":"<pre><code>items() -&gt; Iterable[tuple[K, T]]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>@abstractmethod\ndef items(self) -&gt; Iterable[tuple[K, T]]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.values","title":"values","text":"<pre><code>values() -&gt; Iterable[T]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def values(self) -&gt; Iterable[T]:\n    for _, element in self.items():  # noqa: PERF102\n        yield element\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.keys","title":"keys","text":"<pre><code>keys() -&gt; Iterable[K]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def keys(self) -&gt; Iterable[K]:\n    for key, _ in self.items():  # noqa: PERF102\n        yield key\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.is_hydrated","title":"is_hydrated","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def is_hydrated(self) -&gt; bool:\n    return all(elm.is_hydrated() for elm in self.values())\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.name_elements","title":"name_elements","text":"<pre><code>name_elements() -&gt; None\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def name_elements(self) -&gt; None:\n    for key, element in self.items():\n        if element.name_is_set():\n            # Already named\n            continue\n        element.name = f\"{self.name}[{key_to_str(key)}]\"\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.is_time_series","title":"is_time_series","text":"<pre><code>is_time_series() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def is_time_series(self) -&gt; bool:\n    if self.item_type == \"parameter\":\n        return any(cast(\"ParameterABC[Any]\", parameter).is_time_series for parameter in self.values())\n    msg = \"Only collections of parameters can be time series.\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionABC.ref","title":"ref  <code>abstractmethod</code>","text":"<pre><code>ref(\n    key: K | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; CollectionRef[Any]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>@abstractmethod\ndef ref(\n    self,\n    key: K | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,  # noqa: A002\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; CollectionRef[Any]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.CollectionRef","title":"CollectionRef  <code>dataclass</code>","text":"<pre><code>CollectionRef(\n    name: str,\n    key: K | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n)\n</code></pre> <p>               Bases: <code>ReferenceABC</code></p> <p>Represents a reference to a collection in a model.</p> ATTRIBUTE DESCRIPTION <code>key</code> <p>Key to the collection. If None, it is a reference to the whole collection.</p> <p> TYPE: <code>K | None</code> </p>"},{"location":"reference/pdag/#pdag.CollectionRef.key","title":"key  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>key: K | None = field(default=None)\n</code></pre> <p>Key to the collection. If None, it is a reference to the whole collection.</p>"},{"location":"reference/pdag/#pdag.CoreModel","title":"CoreModel  <code>dataclass</code>","text":"<pre><code>CoreModel(\n    name: str,\n    parameters: dict[str, ParameterABC[Any]],\n    relationships: dict[str, RelationshipABC],\n    collections: dict[\n        str,\n        CollectionABC[\n            Hashable, ParameterABC[Any] | RelationshipABC\n        ],\n    ],\n)\n</code></pre> METHOD DESCRIPTION <code>__post_init__</code> <code>is_hydrated</code> <p>Check if all parameters, collections, and relationships are hydrated.</p> <code>is_dynamic</code> <p>Check if any parameter is dynamic.</p> <code>iter_all_parameters</code> <p>Yield all parameters contained in the model, including those in collections.</p> <code>iter_all_relationships</code> <p>Yield all relationships contained in the model, including those in collections.</p> <code>get_relationship</code> <code>get_parameter</code> <code>get_object_from_ref</code> <code>get_parameter_from_ref</code> <code>get_collection_from_ref</code> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name of the model.</p> <p> TYPE: <code>str</code> </p> <code>parameters</code> <p>Mapping of parameter names to parameters. Parameters contained in collections are not included.</p> <p> TYPE: <code>dict[str, ParameterABC[Any]]</code> </p> <code>relationships</code> <p>Mapping of relationship names to relationships. Relationships contained in collections are not included.</p> <p> TYPE: <code>dict[str, RelationshipABC]</code> </p> <code>collections</code> <p>Mapping of collection names to collections.</p> <p> TYPE: <code>dict[str, CollectionABC[Hashable, ParameterABC[Any] | RelationshipABC]]</code> </p>"},{"location":"reference/pdag/#pdag.CoreModel.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the model.</p>"},{"location":"reference/pdag/#pdag.CoreModel.parameters","title":"parameters  <code>instance-attribute</code>","text":"<pre><code>parameters: dict[str, ParameterABC[Any]]\n</code></pre> <p>Mapping of parameter names to parameters. Parameters contained in collections are not included.</p>"},{"location":"reference/pdag/#pdag.CoreModel.relationships","title":"relationships  <code>instance-attribute</code>","text":"<pre><code>relationships: dict[str, RelationshipABC]\n</code></pre> <p>Mapping of relationship names to relationships. Relationships contained in collections are not included.</p>"},{"location":"reference/pdag/#pdag.CoreModel.collections","title":"collections  <code>instance-attribute</code>","text":"<pre><code>collections: dict[\n    str,\n    CollectionABC[\n        Hashable, ParameterABC[Any] | RelationshipABC\n    ],\n]\n</code></pre> <p>Mapping of collection names to collections.</p>"},{"location":"reference/pdag/#pdag.CoreModel.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    self._parameter_dict = {param.name: param for param in self.iter_all_parameters()}\n    self._relationship_dict = {relationship.name: relationship for relationship in self.iter_all_relationships()}\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.is_hydrated","title":"is_hydrated","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> <p>Check if all parameters, collections, and relationships are hydrated.</p> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def is_hydrated(self) -&gt; bool:\n    \"\"\"Check if all parameters, collections, and relationships are hydrated.\"\"\"\n    return (\n        all(parameter.is_hydrated() for parameter in self.parameters.values())\n        and all(collection.is_hydrated() for collection in self.collections.values())\n        and all(relationship.is_hydrated() for relationship in self.relationships.values())\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.is_dynamic","title":"is_dynamic","text":"<pre><code>is_dynamic() -&gt; bool\n</code></pre> <p>Check if any parameter is dynamic.</p> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def is_dynamic(self) -&gt; bool:\n    \"\"\"Check if any parameter is dynamic.\"\"\"\n    return any(parameter.is_time_series for parameter in self.parameters.values())\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.iter_all_parameters","title":"iter_all_parameters","text":"<pre><code>iter_all_parameters() -&gt; Iterable[ParameterABC[Any]]\n</code></pre> <p>Yield all parameters contained in the model, including those in collections.</p> <p>It does NOT include parameters in sub-models.</p> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def iter_all_parameters(self) -&gt; Iterable[ParameterABC[Any]]:\n    \"\"\"Yield all parameters contained in the model, including those in collections.\n\n    It does NOT include parameters in sub-models.\n    \"\"\"\n    yield from self.parameters.values()\n    for collection in self.collections.values():\n        if collection.item_type == \"parameter\":\n            yield from cast(\"CollectionABC[Hashable, ParameterABC[Any]]\", collection).values()\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.iter_all_relationships","title":"iter_all_relationships","text":"<pre><code>iter_all_relationships() -&gt; Iterable[RelationshipABC]\n</code></pre> <p>Yield all relationships contained in the model, including those in collections.</p> <p>It does NOT include relationships in sub-models.</p> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def iter_all_relationships(self) -&gt; Iterable[RelationshipABC]:\n    \"\"\"Yield all relationships contained in the model, including those in collections.\n\n    It does NOT include relationships in sub-models.\n    \"\"\"\n    yield from self.relationships.values()\n    for collection in self.collections.values():\n        if collection.item_type == \"relationship\":\n            yield from cast(\"CollectionABC[Hashable, RelationshipABC]\", collection).values()\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.get_relationship","title":"get_relationship","text":"<pre><code>get_relationship(name: str) -&gt; RelationshipABC\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def get_relationship(self, name: str) -&gt; RelationshipABC:\n    return self._relationship_dict[name]\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.get_parameter","title":"get_parameter","text":"<pre><code>get_parameter(name: str) -&gt; ParameterABC[Any]\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def get_parameter(self, name: str) -&gt; ParameterABC[Any]:\n    return self._parameter_dict[name]\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.get_object_from_ref","title":"get_object_from_ref","text":"<pre><code>get_object_from_ref(\n    ref: ReferenceABC,\n) -&gt; ParameterABC[Any] | CollectionABC[Any, Any]\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def get_object_from_ref(\n    self,\n    ref: ReferenceABC,\n) -&gt; ParameterABC[Any] | CollectionABC[Any, Any]:\n    if isinstance(ref, ParameterRef):\n        return self.get_parameter_from_ref(ref)\n    if isinstance(ref, CollectionRef):\n        return self.get_collection_from_ref(ref)\n    msg = f\"Reference type {type(ref)} is not supported.\"\n    raise TypeError(msg)\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.get_parameter_from_ref","title":"get_parameter_from_ref","text":"<pre><code>get_parameter_from_ref(\n    ref: ParameterRef,\n) -&gt; ParameterABC[Any]\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def get_parameter_from_ref(self, ref: ParameterRef) -&gt; ParameterABC[Any]:\n    return self.parameters[ref.name]\n</code></pre>"},{"location":"reference/pdag/#pdag.CoreModel.get_collection_from_ref","title":"get_collection_from_ref","text":"<pre><code>get_collection_from_ref(\n    ref: CollectionRef[Any],\n) -&gt; CollectionABC[Any, Any]\n</code></pre> Source code in <code>src/pdag/_core/model.py</code> <pre><code>def get_collection_from_ref(self, ref: CollectionRef[Any]) -&gt; CollectionABC[Any, Any]:\n    return self.collections[ref.name]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecInfo","title":"ExecInfo  <code>dataclass</code>","text":"<pre><code>ExecInfo(attribute: Literal['n_time_steps', 'time'])\n</code></pre> <p>Represents the information available during the execution of a model.</p> ATTRIBUTE DESCRIPTION <code>attribute</code> <p> TYPE: <code>Literal['n_time_steps', 'time']</code> </p>"},{"location":"reference/pdag/#pdag.ExecInfo.attribute","title":"attribute  <code>instance-attribute</code>","text":"<pre><code>attribute: Literal['n_time_steps', 'time']\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship","title":"FunctionRelationship  <code>dataclass</code>","text":"<pre><code>FunctionRelationship(\n    _name: str | EllipsisType,\n    *,\n    at_each_time_step: bool = False,\n    inputs: dict[str, ReferenceABC | ExecInfo],\n    outputs: list[ReferenceABC],\n    function_body: str,\n    output_is_scalar: bool,\n    _function: Callable[P, T] | None = None,\n)\n</code></pre> <p>               Bases: <code>RelationshipABC</code></p> METHOD DESCRIPTION <code>is_hydrated</code> <code>__call__</code> <code>iter_input_refs</code> <code>iter_output_refs</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>inputs</code> <p> TYPE: <code>dict[str, ReferenceABC | ExecInfo]</code> </p> <code>outputs</code> <p> TYPE: <code>list[ReferenceABC]</code> </p> <code>function_body</code> <p> TYPE: <code>str</code> </p> <code>output_is_scalar</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pdag/#pdag.FunctionRelationship.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'function'\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.inputs","title":"inputs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>inputs: dict[str, ReferenceABC | ExecInfo] = field(\n    kw_only=True\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.outputs","title":"outputs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputs: list[ReferenceABC] = field(kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.function_body","title":"function_body  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>function_body: str = field(kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.output_is_scalar","title":"output_is_scalar  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_is_scalar: bool = field(kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.is_hydrated","title":"is_hydrated","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def is_hydrated(self) -&gt; bool:\n    return self._function is not None\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.__call__","title":"__call__","text":"<pre><code>__call__(*args: args, **kwargs: kwargs) -&gt; T\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T:\n    if self._function is None:\n        msg = f\"Function relationship {self.name} has not been hydrated.\"\n        raise ValueError(msg)\n    return self._function(*args, **kwargs)\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.iter_input_refs","title":"iter_input_refs","text":"<pre><code>iter_input_refs() -&gt; Iterable[ReferenceABC | ExecInfo]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def iter_input_refs(self) -&gt; Iterable[ReferenceABC | ExecInfo]:\n    return self.inputs.values()\n</code></pre>"},{"location":"reference/pdag/#pdag.FunctionRelationship.iter_output_refs","title":"iter_output_refs","text":"<pre><code>iter_output_refs() -&gt; Iterable[ReferenceABC]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def iter_output_refs(self) -&gt; Iterable[ReferenceABC]:\n    return self.outputs\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping","title":"Mapping  <code>dataclass</code>","text":"<pre><code>Mapping(name: str, mapping: dict[K, T])\n</code></pre> <p>               Bases: <code>CollectionABC[K, T]</code></p> <p>A collection of parameters or relationships that can be indexed by a string or tuple of strings.</p> METHOD DESCRIPTION <code>__getitem__</code> <code>values</code> <code>items</code> <code>keys</code> <code>ref</code> <p>Create a reference to the mapping.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>mapping</code> <p> TYPE: <code>dict[K, T]</code> </p>"},{"location":"reference/pdag/#pdag.Mapping.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'mapping'\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.mapping","title":"mapping  <code>instance-attribute</code>","text":"<pre><code>mapping: dict[K, T]\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: K) -&gt; T\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def __getitem__(self, key: K) -&gt; T:\n    return self.mapping[key]\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.values","title":"values","text":"<pre><code>values() -&gt; Iterable[T]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def values(self) -&gt; Iterable[T]:\n    yield from self.mapping.values()\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.items","title":"items","text":"<pre><code>items() -&gt; Iterable[tuple[K, T]]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def items(self) -&gt; Iterable[tuple[K, T]]:\n    yield from self.mapping.items()\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.keys","title":"keys","text":"<pre><code>keys() -&gt; Iterable[K]\n</code></pre> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def keys(self) -&gt; Iterable[K]:\n    yield from self.mapping.keys()\n</code></pre>"},{"location":"reference/pdag/#pdag.Mapping.ref","title":"ref","text":"<pre><code>ref(\n    key: str | tuple[str | EllipsisType, ...] | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; MappingRef\n</code></pre> <p>Create a reference to the mapping.</p> Source code in <code>src/pdag/_core/collection.py</code> <pre><code>def ref(\n    self,\n    key: str | tuple[str | EllipsisType, ...] | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,  # noqa: A002\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; MappingRef:\n    \"\"\"Create a reference to the mapping.\"\"\"\n    return MappingRef(\n        name=self.name,\n        key=key,\n        previous=previous,\n        next=next,\n        initial=initial,\n        all_time_steps=all_time_steps,\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.MappingRef","title":"MappingRef  <code>dataclass</code>","text":"<pre><code>MappingRef(\n    name: str,\n    key: K | None = None,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n)\n</code></pre> <p>               Bases: <code>CollectionRef[str | tuple[str | EllipsisType, ...]]</code></p> <p>Represents a reference to a mapping in a model.</p>"},{"location":"reference/pdag/#pdag.ParameterABC","title":"ParameterABC  <code>dataclass</code>","text":"<pre><code>ParameterABC(\n    _name: str | EllipsisType,\n    *,\n    is_time_series: bool = False,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>InitArgsRecorder</code>, <code>ABC</code></p> <p>Abstract base class for all parameters.</p> METHOD DESCRIPTION <code>is_hydrated</code> <p>Check if all required attributes are set.</p> <code>name_is_set</code> <p>Check if the name is set.</p> <code>get_type_hint</code> <code>from_unit_interval</code> <p>Map a value from a unit interval <code>[0, 1]</code> to the parameter value space.</p> <code>ref</code> <p>Create a reference to this parameter in the model definition.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>A string to represent the parameter type. It is not used now, but may be used in the future for model export.</p> <p> TYPE: <code>str</code> </p> <code>is_time_series</code> <p>Whether it is a time-series parameter.</p> <p> TYPE: <code>bool</code> </p> <code>metadata</code> <p>A dictionary where you can store any parameter metadata. It is not used by pdag.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>name</code> <p>Property to get the name of the parameter.</p> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pdag/#pdag.ParameterABC.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'base'\n</code></pre> <p>A string to represent the parameter type. It is not used now, but may be used in the future for model export.</p>"},{"location":"reference/pdag/#pdag.ParameterABC.is_time_series","title":"is_time_series  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_time_series: bool = field(default=False, kw_only=True)\n</code></pre> <p>Whether it is a time-series parameter.</p>"},{"location":"reference/pdag/#pdag.ParameterABC.metadata","title":"metadata  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>metadata: dict[str, Any] = field(\n    default_factory=dict, kw_only=True\n)\n</code></pre> <p>A dictionary where you can store any parameter metadata. It is not used by pdag.</p>"},{"location":"reference/pdag/#pdag.ParameterABC.is_hydrated","title":"is_hydrated","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> <p>Check if all required attributes are set.</p> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def is_hydrated(self) -&gt; bool:\n    \"\"\"Check if all required attributes are set.\"\"\"\n    return self.name_is_set()\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterABC.name_is_set","title":"name_is_set","text":"<pre><code>name_is_set() -&gt; bool\n</code></pre> <p>Check if the name is set.</p> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def name_is_set(self) -&gt; bool:\n    \"\"\"Check if the name is set.\"\"\"\n    return isinstance(self._name, str)\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterABC.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre> <p>Property to get the name of the parameter.</p> <p>If you try to access it before it is set, it will raise a ValueError.</p>"},{"location":"reference/pdag/#pdag.ParameterABC.get_type_hint","title":"get_type_hint  <code>abstractmethod</code>","text":"<pre><code>get_type_hint() -&gt; str\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>@abstractmethod\ndef get_type_hint(self) -&gt; str:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterABC.from_unit_interval","title":"from_unit_interval  <code>abstractmethod</code>","text":"<pre><code>from_unit_interval(value: float) -&gt; T\n</code></pre> <p>Map a value from a unit interval <code>[0, 1]</code> to the parameter value space.</p> <p>This method should be implemented so that the uniform distribution in the unit interval corresponds to the \"uniform\" distribution in the parameter value space.</p> <p>Note</p> <p>We use the term \"uniform\" in a loose sense. We don't treat the resulting distribution as a probability distribution and the reason that the distribution should be as \"uniform\" as possible is to sample the parameter value space efficiently.</p> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>@abstractmethod\ndef from_unit_interval(self, value: float) -&gt; T:\n    \"\"\"Map a value from a unit interval `[0, 1]` to the parameter value space.\n\n    This method should be implemented so that the uniform distribution in the unit interval\n    corresponds to the \"uniform\" distribution in the parameter value space.\n\n    !!! note\n        We use the term \"uniform\" in a loose sense.\n        We don't treat the resulting distribution as a probability distribution and\n        the reason that the distribution should be as \"uniform\" as possible\n        is to sample the parameter value space efficiently.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterABC.ref","title":"ref","text":"<pre><code>ref(\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; ParameterRef\n</code></pre> <p>Create a reference to this parameter in the model definition.</p> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def ref(\n    self,\n    *,\n    previous: bool = False,\n    next: bool = False,  # noqa: A002\n    initial: bool = False,\n    all_time_steps: bool = False,\n) -&gt; ParameterRef:\n    \"\"\"Create a reference to this parameter in the model definition.\"\"\"\n    return ParameterRef(\n        name=self.name,\n        previous=previous,\n        next=next,\n        initial=initial,\n        all_time_steps=all_time_steps,\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterRef","title":"ParameterRef  <code>dataclass</code>","text":"<pre><code>ParameterRef(\n    name: str,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n)\n</code></pre> <p>               Bases: <code>ReferenceABC</code></p> <p>Represents a reference to a parameter in a model.</p>"},{"location":"reference/pdag/#pdag.RealParameter","title":"RealParameter  <code>dataclass</code>","text":"<pre><code>RealParameter(\n    _name: str | EllipsisType,\n    unit: str | None = None,\n    lower_bound: float | None = None,\n    upper_bound: float | None = None,\n    *,\n    is_time_series: bool = False,\n    metadata: dict[str, Any] = dict(),\n)\n</code></pre> <p>               Bases: <code>ParameterABC[float]</code></p> METHOD DESCRIPTION <code>get_type_hint</code> <code>from_unit_interval</code> <p>Linearly map a value from a unit interval <code>[0, 1]</code> to the parameter value space.</p> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>unit</code> <p> TYPE: <code>str | None</code> </p> <code>lower_bound</code> <p> TYPE: <code>float | None</code> </p> <code>upper_bound</code> <p> TYPE: <code>float | None</code> </p>"},{"location":"reference/pdag/#pdag.RealParameter.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'real'\n</code></pre>"},{"location":"reference/pdag/#pdag.RealParameter.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: str | None = None\n</code></pre>"},{"location":"reference/pdag/#pdag.RealParameter.lower_bound","title":"lower_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lower_bound: float | None = None\n</code></pre>"},{"location":"reference/pdag/#pdag.RealParameter.upper_bound","title":"upper_bound  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>upper_bound: float | None = None\n</code></pre>"},{"location":"reference/pdag/#pdag.RealParameter.get_type_hint","title":"get_type_hint","text":"<pre><code>get_type_hint() -&gt; str\n</code></pre> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def get_type_hint(self) -&gt; str:\n    return \"float\"\n</code></pre>"},{"location":"reference/pdag/#pdag.RealParameter.from_unit_interval","title":"from_unit_interval","text":"<pre><code>from_unit_interval(value: float) -&gt; float\n</code></pre> <p>Linearly map a value from a unit interval <code>[0, 1]</code> to the parameter value space.</p> <p>0 corresponds to the lower bound and 1 corresponds to the upper bound.</p> Source code in <code>src/pdag/_core/parameter.py</code> <pre><code>def from_unit_interval(self, value: float) -&gt; float:\n    \"\"\"Linearly map a value from a unit interval `[0, 1]` to the parameter value space.\n\n    0 corresponds to the lower bound and 1 corresponds to the upper bound.\n    \"\"\"\n    if self.lower_bound is None or self.upper_bound is None:\n        msg = f\"Lower and upper bounds must be set to convert from unit interval. Parameter: {self.name}\"\n        raise ValueError(msg)\n    return self.lower_bound + value * (self.upper_bound - self.lower_bound)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC","title":"ReferenceABC  <code>dataclass</code>","text":"<pre><code>ReferenceABC(\n    name: str,\n    *,\n    previous: bool = False,\n    next: bool = False,\n    initial: bool = False,\n    all_time_steps: bool = False,\n)\n</code></pre> <p>               Bases: <code>InitArgsRecorder</code></p> <p>Represents a reference to a parameter or collection in a model.</p> METHOD DESCRIPTION <code>__post_init__</code> ATTRIBUTE DESCRIPTION <code>name</code> <p>Name of the parameter or collection.</p> <p> TYPE: <code>str</code> </p> <code>previous</code> <p> TYPE: <code>bool</code> </p> <code>next</code> <p> TYPE: <code>bool</code> </p> <code>initial</code> <p> TYPE: <code>bool</code> </p> <code>all_time_steps</code> <p> TYPE: <code>bool</code> </p> <code>__init_args__</code> <p> TYPE: <code>tuple[Any, ...]</code> </p> <code>__init_kwargs__</code> <p> TYPE: <code>dict[str, Any]</code> </p> <code>normal</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pdag/#pdag.ReferenceABC.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the parameter or collection.</p>"},{"location":"reference/pdag/#pdag.ReferenceABC.previous","title":"previous  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>previous: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.next","title":"next  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>next: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.initial","title":"initial  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>initial: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.all_time_steps","title":"all_time_steps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>all_time_steps: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.__init_args__","title":"__init_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__init_args__: tuple[Any, ...] = field(\n    init=False, compare=False, hash=False\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.__init_kwargs__","title":"__init_kwargs__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__init_kwargs__: dict[str, Any] = field(\n    init=False, compare=False, hash=False\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/pdag/_core/reference.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    if sum([self.previous, self.next, self.initial, self.all_time_steps]) &gt; 1:\n        msg = \"Reference cannot have more than one of previous, next, initial, or all_time_steps set.\"\n        raise ValueError(msg)\n    if not self.name.isidentifier():\n        msg = \"Reference name must be a valid identifier.\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"reference/pdag/#pdag.ReferenceABC.normal","title":"normal  <code>property</code>","text":"<pre><code>normal: bool\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC","title":"RelationshipABC  <code>dataclass</code>","text":"<pre><code>RelationshipABC(\n    _name: str | EllipsisType,\n    *,\n    at_each_time_step: bool = False,\n)\n</code></pre> <p>               Bases: <code>ABC</code>, <code>InitArgsRecorder</code></p> METHOD DESCRIPTION <code>name_is_set</code> <code>is_hydrated</code> <code>iter_input_refs</code> <code>iter_output_refs</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>at_each_time_step</code> <p> TYPE: <code>bool</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>includes_past</code> <p> TYPE: <code>bool</code> </p> <code>includes_future</code> <p> TYPE: <code>bool</code> </p>"},{"location":"reference/pdag/#pdag.RelationshipABC.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'relationship'\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.at_each_time_step","title":"at_each_time_step  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>at_each_time_step: bool = field(default=False, kw_only=True)\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.name_is_set","title":"name_is_set","text":"<pre><code>name_is_set() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def name_is_set(self) -&gt; bool:\n    return isinstance(self._name, str)\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.name","title":"name  <code>property</code> <code>writable</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.is_hydrated","title":"is_hydrated  <code>abstractmethod</code>","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>@abstractmethod\ndef is_hydrated(self) -&gt; bool:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.iter_input_refs","title":"iter_input_refs  <code>abstractmethod</code>","text":"<pre><code>iter_input_refs() -&gt; Iterable[ReferenceABC | ExecInfo]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>@abstractmethod\ndef iter_input_refs(self) -&gt; Iterable[ReferenceABC | ExecInfo]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.iter_output_refs","title":"iter_output_refs  <code>abstractmethod</code>","text":"<pre><code>iter_output_refs() -&gt; Iterable[ReferenceABC]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>@abstractmethod\ndef iter_output_refs(self) -&gt; Iterable[ReferenceABC]:\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.includes_past","title":"includes_past  <code>property</code>","text":"<pre><code>includes_past: bool\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipABC.includes_future","title":"includes_future  <code>property</code>","text":"<pre><code>includes_future: bool\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship","title":"SubModelRelationship  <code>dataclass</code>","text":"<pre><code>SubModelRelationship(\n    _name: str | EllipsisType,\n    submodel_name: str,\n    inputs: dict[ReferenceABC, ReferenceABC],\n    outputs: dict[ReferenceABC, ReferenceABC],\n    *,\n    at_each_time_step: bool = False,\n    _submodel: CoreModel | None = None,\n)\n</code></pre> <p>               Bases: <code>RelationshipABC</code></p> METHOD DESCRIPTION <code>is_hydrated</code> <code>iter_input_refs</code> <code>iter_output_refs</code> ATTRIBUTE DESCRIPTION <code>type</code> <p> TYPE: <code>str</code> </p> <code>submodel_name</code> <p> TYPE: <code>str</code> </p> <code>inputs</code> <p> TYPE: <code>dict[ReferenceABC, ReferenceABC]</code> </p> <code>outputs</code> <p> TYPE: <code>dict[ReferenceABC, ReferenceABC]</code> </p> <code>submodel</code> <p> TYPE: <code>CoreModel</code> </p>"},{"location":"reference/pdag/#pdag.SubModelRelationship.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: str = 'submodel'\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.submodel_name","title":"submodel_name  <code>instance-attribute</code>","text":"<pre><code>submodel_name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.inputs","title":"inputs  <code>instance-attribute</code>","text":"<pre><code>inputs: dict[ReferenceABC, ReferenceABC]\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.outputs","title":"outputs  <code>instance-attribute</code>","text":"<pre><code>outputs: dict[ReferenceABC, ReferenceABC]\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.is_hydrated","title":"is_hydrated","text":"<pre><code>is_hydrated() -&gt; bool\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def is_hydrated(self) -&gt; bool:\n    return self._submodel is not None\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.iter_input_refs","title":"iter_input_refs","text":"<pre><code>iter_input_refs() -&gt; Iterable[ReferenceABC]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def iter_input_refs(self) -&gt; Iterable[ReferenceABC]:\n    return self.inputs.values()\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.iter_output_refs","title":"iter_output_refs","text":"<pre><code>iter_output_refs() -&gt; Iterable[ReferenceABC]\n</code></pre> Source code in <code>src/pdag/_core/relationship.py</code> <pre><code>def iter_output_refs(self) -&gt; Iterable[ReferenceABC]:\n    return self.outputs.values()\n</code></pre>"},{"location":"reference/pdag/#pdag.SubModelRelationship.submodel","title":"submodel  <code>property</code>","text":"<pre><code>submodel: CoreModel\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel","title":"ExecutionModel  <code>dataclass</code>","text":"<pre><code>ExecutionModel(\n    parameter_ids: set[ParameterId],\n    relationship_infos: dict[\n        RelationshipId, FunctionRelationshipInfo\n    ],\n    input_parameter_id_to_relationship_ids: dict[\n        ParameterId, set[RelationshipId]\n    ],\n    relationship_id_to_output_parameter_ids: dict[\n        RelationshipId, set[ParameterId]\n    ],\n    port_mapping: dict[ParameterId, ParameterId],\n    n_time_steps: int | None = None,\n    *,\n    _core_model: CoreModel,\n)\n</code></pre> METHOD DESCRIPTION <code>__post_init__</code> <code>input_parameter_ids</code> <code>input_parameters</code> ATTRIBUTE DESCRIPTION <code>parameter_ids</code> <p> TYPE: <code>set[ParameterId]</code> </p> <code>relationship_infos</code> <p> TYPE: <code>dict[RelationshipId, FunctionRelationshipInfo]</code> </p> <code>input_parameter_id_to_relationship_ids</code> <p> TYPE: <code>dict[ParameterId, set[RelationshipId]]</code> </p> <code>relationship_id_to_output_parameter_ids</code> <p> TYPE: <code>dict[RelationshipId, set[ParameterId]]</code> </p> <code>port_mapping</code> <p> TYPE: <code>dict[ParameterId, ParameterId]</code> </p> <code>n_time_steps</code> <p> TYPE: <code>int | None</code> </p> <code>relationship_id_to_input_parameter_ids</code> <p> TYPE: <code>dict[RelationshipId, set[ParameterId]]</code> </p> <code>output_parameter_id_to_relationship_ids</code> <p> TYPE: <code>dict[ParameterId, set[RelationshipId]]</code> </p> <code>port_mapping_inverse</code> <p> TYPE: <code>dict[ParameterId, ParameterId]</code> </p> <code>topologically_sorted_node_ids</code> <p> TYPE: <code>list[NodeId]</code> </p>"},{"location":"reference/pdag/#pdag.ExecutionModel.parameter_ids","title":"parameter_ids  <code>instance-attribute</code>","text":"<pre><code>parameter_ids: set[ParameterId]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.relationship_infos","title":"relationship_infos  <code>instance-attribute</code>","text":"<pre><code>relationship_infos: dict[\n    RelationshipId, FunctionRelationshipInfo\n]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.input_parameter_id_to_relationship_ids","title":"input_parameter_id_to_relationship_ids  <code>instance-attribute</code>","text":"<pre><code>input_parameter_id_to_relationship_ids: dict[\n    ParameterId, set[RelationshipId]\n]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.relationship_id_to_output_parameter_ids","title":"relationship_id_to_output_parameter_ids  <code>instance-attribute</code>","text":"<pre><code>relationship_id_to_output_parameter_ids: dict[\n    RelationshipId, set[ParameterId]\n]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.port_mapping","title":"port_mapping  <code>instance-attribute</code>","text":"<pre><code>port_mapping: dict[ParameterId, ParameterId]\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.n_time_steps","title":"n_time_steps  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_time_steps: int | None = None\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.relationship_id_to_input_parameter_ids","title":"relationship_id_to_input_parameter_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>relationship_id_to_input_parameter_ids: dict[\n    RelationshipId, set[ParameterId]\n] = field(init=False, repr=False, compare=False)\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.output_parameter_id_to_relationship_ids","title":"output_parameter_id_to_relationship_ids  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>output_parameter_id_to_relationship_ids: dict[\n    ParameterId, set[RelationshipId]\n] = field(init=False, repr=False, compare=False)\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.port_mapping_inverse","title":"port_mapping_inverse  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>port_mapping_inverse: dict[ParameterId, ParameterId] = (\n    field(init=False, repr=False, compare=False)\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> Source code in <code>src/pdag/_exec/model.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    relationship_id_to_input_parameter_ids_dd: defaultdict[RelationshipId, set[ParameterId]] = defaultdict(\n        set,\n    )\n    for input_parameter_id, relationship_ids in self.input_parameter_id_to_relationship_ids.items():\n        for relationship_id in relationship_ids:\n            relationship_id_to_input_parameter_ids_dd[relationship_id].add(input_parameter_id)\n    self.relationship_id_to_input_parameter_ids = dict(relationship_id_to_input_parameter_ids_dd)\n\n    output_parameter_id_to_relationship_ids_dd: defaultdict[ParameterId, set[RelationshipId]] = defaultdict(\n        set,\n    )\n    for relationship_id, output_parameter_ids in self.relationship_id_to_output_parameter_ids.items():\n        for output_parameter_id in output_parameter_ids:\n            output_parameter_id_to_relationship_ids_dd[output_parameter_id].add(relationship_id)\n    self.output_parameter_id_to_relationship_ids = dict(output_parameter_id_to_relationship_ids_dd)\n\n    self.port_mapping_inverse = {value: key for key, value in self.port_mapping.items()}\n\n    # Calculate topological sort\n    dependencies_dd: defaultdict[NodeId, set[NodeId]] = defaultdict(\n        set,\n        cast(\"dict[NodeId, set[NodeId]]\", self.input_parameter_id_to_relationship_ids)\n        | cast(\"dict[NodeId, set[NodeId]]\", self.relationship_id_to_output_parameter_ids),\n    )\n    for src, dest in self.port_mapping.items():\n        dependencies_dd[src].add(dest)\n    dependencies = dict(dependencies_dd)\n    # Sort nodes topologically\n    self._topologically_sorted_node_ids = topological_sort(dependencies)\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.input_parameter_ids","title":"input_parameter_ids","text":"<pre><code>input_parameter_ids() -&gt; set[ParameterId]\n</code></pre> Source code in <code>src/pdag/_exec/model.py</code> <pre><code>def input_parameter_ids(self) -&gt; set[ParameterId]:\n    return {\n        parameter_id\n        for parameter_id in self.parameter_ids\n        if parameter_id not in self.output_parameter_id_to_relationship_ids\n        and parameter_id not in self.port_mapping_inverse\n    }\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.input_parameters","title":"input_parameters","text":"<pre><code>input_parameters() -&gt; dict[ParameterId, ParameterABC[Any]]\n</code></pre> Source code in <code>src/pdag/_exec/model.py</code> <pre><code>def input_parameters(self) -&gt; dict[ParameterId, ParameterABC[Any]]:\n    return {\n        parameter_id: parameter_id_to_parameter(parameter_id, root_model=self._core_model)\n        for parameter_id in self.input_parameter_ids()\n    }\n</code></pre>"},{"location":"reference/pdag/#pdag.ExecutionModel.topologically_sorted_node_ids","title":"topologically_sorted_node_ids  <code>property</code>","text":"<pre><code>topologically_sorted_node_ids: list[NodeId]\n</code></pre>"},{"location":"reference/pdag/#pdag.NodeId","title":"NodeId  <code>module-attribute</code>","text":"<pre><code>NodeId: TypeAlias = ParameterId | RelationshipId\n</code></pre>"},{"location":"reference/pdag/#pdag.ParameterId","title":"ParameterId  <code>module-attribute</code>","text":"<pre><code>ParameterId: TypeAlias = (\n    StaticParameterId | TimeSeriesParameterId\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.RelationshipId","title":"RelationshipId  <code>module-attribute</code>","text":"<pre><code>RelationshipId: TypeAlias = (\n    StaticRelationshipId | TimeSeriesRelationshipId\n)\n</code></pre>"},{"location":"reference/pdag/#pdag.StaticParameterId","title":"StaticParameterId  <code>dataclass</code>","text":"<pre><code>StaticParameterId(model_path: ModelPathType, name: str)\n</code></pre> <p>               Bases: <code>ParameterIdMixin</code></p> ATTRIBUTE DESCRIPTION <code>model_path</code> <p> TYPE: <code>ModelPathType</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pdag/#pdag.StaticParameterId.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path: ModelPathType\n</code></pre>"},{"location":"reference/pdag/#pdag.StaticParameterId.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.StaticRelationshipId","title":"StaticRelationshipId  <code>dataclass</code>","text":"<pre><code>StaticRelationshipId(model_path: ModelPathType, name: str)\n</code></pre> <p>               Bases: <code>NodeIdMixin</code></p> ATTRIBUTE DESCRIPTION <code>model_path</code> <p> TYPE: <code>ModelPathType</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p>"},{"location":"reference/pdag/#pdag.StaticRelationshipId.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path: ModelPathType\n</code></pre>"},{"location":"reference/pdag/#pdag.StaticRelationshipId.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesParameterId","title":"TimeSeriesParameterId  <code>dataclass</code>","text":"<pre><code>TimeSeriesParameterId(\n    model_path: ModelPathType, name: str, time_step: int\n)\n</code></pre> <p>               Bases: <code>ParameterIdMixin</code></p> ATTRIBUTE DESCRIPTION <code>model_path</code> <p> TYPE: <code>ModelPathType</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>time_step</code> <p> TYPE: <code>int</code> </p>"},{"location":"reference/pdag/#pdag.TimeSeriesParameterId.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path: ModelPathType\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesParameterId.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesParameterId.time_step","title":"time_step  <code>instance-attribute</code>","text":"<pre><code>time_step: int\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesRelationshipId","title":"TimeSeriesRelationshipId  <code>dataclass</code>","text":"<pre><code>TimeSeriesRelationshipId(\n    model_path: ModelPathType, name: str, time_step: int\n)\n</code></pre> <p>               Bases: <code>NodeIdMixin</code></p> ATTRIBUTE DESCRIPTION <code>model_path</code> <p> TYPE: <code>ModelPathType</code> </p> <code>name</code> <p> TYPE: <code>str</code> </p> <code>time_step</code> <p> TYPE: <code>int</code> </p>"},{"location":"reference/pdag/#pdag.TimeSeriesRelationshipId.model_path","title":"model_path  <code>instance-attribute</code>","text":"<pre><code>model_path: ModelPathType\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesRelationshipId.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.TimeSeriesRelationshipId.time_step","title":"time_step  <code>instance-attribute</code>","text":"<pre><code>time_step: int\n</code></pre>"},{"location":"reference/pdag/#pdag.create_exec_model_from_core_model","title":"create_exec_model_from_core_model","text":"<pre><code>create_exec_model_from_core_model(\n    core_model: CoreModel, *, n_time_steps: int = 1\n) -&gt; ExecutionModel\n</code></pre> Source code in <code>src/pdag/_exec/to_exec_model.py</code> <pre><code>def create_exec_model_from_core_model(\n    core_model: CoreModel,\n    *,\n    n_time_steps: int = 1,\n) -&gt; ExecutionModel:\n    parameter_ids: set[ParameterId] = set()\n    for model_path, _, parameter in _iter_parameters_recursively(core_model):\n        assert isinstance(parameter.name, str)\n        if parameter.is_time_series:\n            parameter_ids.update(\n                TimeSeriesParameterId(\n                    model_path=model_path,\n                    name=parameter.name,\n                    time_step=time_step,\n                )\n                for time_step in range(n_time_steps)\n            )\n        else:\n            parameter_ids.add(\n                StaticParameterId(model_path=model_path, name=parameter.name),\n            )\n\n    relationships: dict[RelationshipId, FunctionRelationshipInfo] = {}\n    input_parameter_id_to_relationship_ids: dict[ParameterId, set[RelationshipId]] = {}\n    relationship_id_to_output_parameter_ids: dict[RelationshipId, set[ParameterId]] = {}\n    port_mapping: dict[ParameterId, ParameterId] = {}\n\n    for (\n        model_path,\n        model,\n        function_relationship,\n    ) in _iter_function_relationships_recursively(core_model):\n        if function_relationship.at_each_time_step:\n            (\n                input_parameter_id_to_relationship_ids_local,\n                relationship_id_to_output_parameter_ids_local,\n                relationships_local,\n            ) = _calculate_dependencies_of_time_series_function_relationship(\n                function_relationship,\n                core_model=model,\n                model_path=model_path,\n                n_time_steps=n_time_steps,\n            )\n        else:\n            (\n                input_parameter_id_to_relationship_ids_local,\n                relationship_id_to_output_parameter_ids_local,\n                relationships_local,\n            ) = _calculate_dependencies_of_static_function_relationship(\n                function_relationship,\n                core_model=model,\n                model_path=model_path,\n                n_time_steps=n_time_steps,\n            )\n        relationships.update(relationships_local)\n\n        input_parameter_id_to_relationship_ids = merge_two_set_dicts(\n            input_parameter_id_to_relationship_ids,\n            input_parameter_id_to_relationship_ids_local,\n        )\n        relationship_id_to_output_parameter_ids = merge_two_set_dicts(\n            relationship_id_to_output_parameter_ids,\n            relationship_id_to_output_parameter_ids_local,\n        )\n\n    for (\n        model_path,\n        model,\n        sub_model_relationship,\n    ) in _iter_submodel_relationships_recursively(core_model):\n        if sub_model_relationship.at_each_time_step:\n            port_mapping_local = _calculate_port_mapping_of_time_series_submodel_relationship(\n                sub_model_relationship,\n                core_model=model,\n                model_path=model_path,\n                n_time_steps=n_time_steps,\n            )\n        else:\n            port_mapping_local = _calculate_port_mapping_of_static_submodel_relationship(\n                sub_model_relationship,\n                core_model=model,\n                model_path=model_path,\n                n_time_steps=n_time_steps,\n            )\n        port_mapping.update(port_mapping_local)\n\n    return ExecutionModel(\n        parameter_ids=parameter_ids,\n        relationship_infos=relationships,\n        input_parameter_id_to_relationship_ids=input_parameter_id_to_relationship_ids,\n        relationship_id_to_output_parameter_ids=relationship_id_to_output_parameter_ids,\n        port_mapping=port_mapping,\n        n_time_steps=n_time_steps,\n        _core_model=core_model,\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.execute_exec_model","title":"execute_exec_model","text":"<pre><code>execute_exec_model(\n    exec_model: ExecutionModel,\n    inputs: Mapping[ParameterId, Any],\n) -&gt; dict[ParameterId, Any]\n</code></pre> Source code in <code>src/pdag/_exec/core.py</code> <pre><code>def execute_exec_model(  # noqa: C901, PLR0912, PLR0915\n    exec_model: ExecutionModel,\n    inputs: Mapping[ParameterId, Any],\n) -&gt; dict[ParameterId, Any]:\n    # TODO: Exec only part of the model (in which case you need to sort the nodes again?)\n    sorted_nodes_queue = deque(exec_model.topologically_sorted_node_ids)\n    results: dict[ParameterId, Any] = {}\n    while sorted_nodes_queue:\n        node_id = sorted_nodes_queue.popleft()\n\n        if node_id in results:\n            continue\n\n        if isinstance(node_id, StaticParameterId | TimeSeriesParameterId):\n            if node_id in inputs:\n                results[node_id] = inputs[node_id]\n                continue\n            if node_id in exec_model.port_mapping_inverse:\n                parent_node_id = exec_model.port_mapping_inverse[node_id]\n                if parent_node_id in inputs:\n                    results[node_id] = inputs[parent_node_id]\n                    continue\n                if parent_node_id in results:\n                    results[node_id] = results[parent_node_id]\n                    continue\n                msg = f\"Parent node {parent_node_id} not in results\"\n                raise ValueError(msg)\n            msg = f\"Node {node_id} not in inputs or port_mapping\"\n            raise ValueError(msg)\n\n        if isinstance(node_id, StaticRelationshipId | TimeSeriesRelationshipId):\n            relationship_info = exec_model.relationship_infos[node_id]\n\n            input_values: dict[str, Any] = {}\n            for input_arg_name, connector_or_exec_info in relationship_info.input_parameter_info.items():\n                if isinstance(connector_or_exec_info, ExecInfoType):\n                    input_values[input_arg_name] = _get_exec_info_value(\n                        exec_model,\n                        connector_or_exec_info,\n                        node_id,\n                    )\n                    continue\n                if isinstance(connector_or_exec_info, ScalarConnector):\n                    input_values[input_arg_name] = results[connector_or_exec_info.parameter_id]\n                    continue\n                if isinstance(connector_or_exec_info, MappingConnector):\n                    input_values[input_arg_name] = {\n                        key: results[param_id] for key, param_id in connector_or_exec_info.parameter_ids.items()\n                    }\n                    continue\n                if isinstance(connector_or_exec_info, MappingListConnector):\n                    input_values[input_arg_name] = [\n                        {key: results[param_id] for key, param_id in mapping.items()}\n                        for mapping in connector_or_exec_info.parameter_ids\n                    ]\n                    continue\n                if isinstance(connector_or_exec_info, ArrayConnector):\n                    value_array = np.empty(connector_or_exec_info.parameter_ids.shape, dtype=object)\n                    for index, param_id in np.ndenumerate(connector_or_exec_info.parameter_ids):\n                        value_array[index] = results[param_id]\n                    input_values[input_arg_name] = value_array.tolist()\n                    continue\n                msg = f\"Connector type {type(connector_or_exec_info)} is not supported.\"\n                raise TypeError(msg)\n\n            output_values = relationship_info.function_relationship(**input_values)\n\n            if relationship_info.function_relationship.output_is_scalar:\n                output_values = (output_values,)\n            for connector, output_value in zip(\n                relationship_info.output_parameter_info,\n                output_values,\n                strict=True,\n            ):\n                if isinstance(connector, ScalarConnector):\n                    results[connector.parameter_id] = output_value\n                    continue\n                if isinstance(connector, MappingConnector):\n                    for key, param_id in connector.parameter_ids.items():\n                        results[param_id] = output_value[key]\n                    continue\n                if isinstance(connector, MappingListConnector):\n                    for mapping, output_value_item in zip(connector.parameter_ids, output_value, strict=True):\n                        for key, param_id in mapping.items():\n                            results[param_id] = output_value_item[key]\n                    continue\n                if isinstance(connector, ArrayConnector):\n                    for index, param_id in np.ndenumerate(connector.parameter_ids):\n                        results[param_id] = np.asarray(output_value, dtype=object)[index]\n                    continue\n                msg = f\"Connector type {type(connector)} is not supported.\"\n                raise TypeError(msg)\n\n    return results\n</code></pre>"},{"location":"reference/pdag/#pdag.distance_constrained_sampling","title":"distance_constrained_sampling","text":"<pre><code>distance_constrained_sampling(\n    parameters: dict[ParameterId, ParameterABC[Any]],\n    n_samples: int,\n    *,\n    budget: float,\n    rng: Generator | None = None,\n    uniform_in_distance: bool = True,\n) -&gt; list[dict[ParameterId, Any]]\n</code></pre> Source code in <code>src/pdag/_experiment/distance_sampling.py</code> <pre><code>def distance_constrained_sampling(\n    parameters: dict[ParameterId, ParameterABC[Any]],\n    n_samples: int,\n    *,\n    budget: float,\n    rng: np.random.Generator | None = None,\n    uniform_in_distance: bool = True,\n) -&gt; list[dict[ParameterId, Any]]:\n    if not all(isinstance(parameter, RealParameter) for parameter in parameters.values()):\n        msg = \"Only real parameters are supported.\"\n        raise NotImplementedError(msg)\n\n    n_parameters = len(parameters)\n    rng = np.random.default_rng() if rng is None else rng\n    direction_samples = normalize(rng.normal(size=(n_samples, n_parameters)), axis=-1)\n    radius_samples_normalized = (\n        rng.uniform(size=n_samples) if uniform_in_distance else np.pow(rng.uniform(size=n_samples), 1 / n_parameters)\n    )\n    radius_samples = budget * radius_samples_normalized\n    distance_samples = np.abs(radius_samples[:, np.newaxis] * direction_samples)\n\n    # TODO: Support other parameter types apart from RealParameter\n    return [\n        {\n            parameter_id: inverse_distance_real(cast(\"RealParameter\", parameter), distance, rng=rng)\n            for (parameter_id, parameter), distance in zip(parameters.items(), distance_sample, strict=True)\n        }\n        for distance_sample in distance_samples\n    ]\n</code></pre>"},{"location":"reference/pdag/#pdag.results_to_df","title":"results_to_df","text":"<pre><code>results_to_df(\n    results: Iterable[\n        Mapping[\n            StaticParameterId | TimeSeriesParameterId | str,\n            Any,\n        ]\n    ],\n    case_id_factory: Callable[\n        [], str\n    ] = generate_random_string,\n) -&gt; DataFrame\n</code></pre> Source code in <code>src/pdag/_experiment/results.py</code> <pre><code>def results_to_df(\n    results: Iterable[Mapping[pdag.StaticParameterId | pdag.TimeSeriesParameterId | str, Any]],\n    case_id_factory: Callable[[], str] = generate_random_string,\n) -&gt; pl.DataFrame:\n    rows: list[dict[str, Any]] = []\n    for res in results:\n        case_id = case_id_factory()\n        # Containers for static and time-series parameters.\n        static_data: dict[str, Any] = {}\n        timeseries_data_dd: defaultdict[int, dict[str, Any]] = defaultdict(dict)\n        for parameter_id, value in res.items():\n            # We assume that static parameter_ids have only the `name` attribute,\n            # while time series parameter_ids have `name` and `time_step` attributes.\n            if isinstance(parameter_id, pdag.StaticParameterId):\n                static_data[parameter_id.parameter_path_str] = value\n            elif isinstance(parameter_id, pdag.TimeSeriesParameterId):\n                ts = parameter_id.time_step\n                timeseries_data_dd[ts][parameter_id.parameter_path_str] = value\n\n        timeseries_data = dict(timeseries_data_dd)\n\n        # For each time step, create a row that merges static and time-series parameters.\n        metadata: dict[str, Any] = res.get(\"metadata\", {})\n        for ts, ts_params in sorted(timeseries_data.items()):\n            row = {\"case_id\": case_id, \"time_step\": ts} | metadata\n            # Include static parameters (repeated for each time step)\n            row.update(static_data)\n            # Include time-series parameters for the current time step\n            row.update(ts_params)\n            rows.append(row)\n\n    return pl.DataFrame(rows)\n</code></pre>"},{"location":"reference/pdag/#pdag.run_experiments","title":"run_experiments","text":"<pre><code>run_experiments(\n    exec_model: ExecutionModel,\n    cases: Iterable[Mapping[ParameterId, Any]],\n    *,\n    metadata: Iterable[Mapping[str, Any]],\n    return_type: Literal[\"list\"],\n    n_cases: int | None = None,\n) -&gt; list[dict[ParameterId, Any]]\n</code></pre><pre><code>run_experiments(\n    exec_model: ExecutionModel,\n    cases: Iterable[Mapping[ParameterId, Any]],\n    *,\n    metadata: None = None,\n    return_type: Literal[\"list\"],\n    n_cases: int | None = None,\n) -&gt; list[dict[ParameterId | str, Any]]\n</code></pre><pre><code>run_experiments(\n    exec_model: ExecutionModel,\n    cases: Iterable[Mapping[ParameterId, Any]],\n    *,\n    metadata: Iterable[Mapping[str, Any]] | None = None,\n    return_type: Literal[\"polars\"] = \"polars\",\n    n_cases: int | None = None,\n) -&gt; DataFrame\n</code></pre> <pre><code>run_experiments(\n    exec_model: ExecutionModel,\n    cases: Iterable[Mapping[ParameterId, Any]],\n    *,\n    metadata: Iterable[Mapping[str, Any]] | None = None,\n    return_type: Literal[\"list\", \"polars\"] = \"polars\",\n    n_cases: int | None = None,\n) -&gt; (\n    list[dict[ParameterId, Any]]\n    | list[dict[ParameterId | str, Any]]\n    | DataFrame\n)\n</code></pre> Source code in <code>src/pdag/_experiment/runner.py</code> <pre><code>def run_experiments(\n    exec_model: ExecutionModel,\n    cases: Iterable[Mapping[ParameterId, Any]],\n    *,\n    metadata: Iterable[Mapping[str, Any]] | None = None,\n    return_type: Literal[\"list\", \"polars\"] = \"polars\",\n    n_cases: int | None = None,\n) -&gt; list[dict[ParameterId, Any]] | list[dict[ParameterId | str, Any]] | pl.DataFrame:\n    results_iter = (\n        execute_exec_model(\n            exec_model,\n            inputs=case,\n        )\n        | {\"metadata\": mtd}\n        for case, mtd in tqdm(\n            zip(cases, metadata if metadata is not None else _infinite_empty_dict_generator(), strict=False),\n            total=n_cases,\n        )\n    )\n    match return_type:\n        case \"list\":\n            return list(results_iter)\n        case \"polars\":\n            return results_to_df(results_iter)\n        case _:\n            msg = f\"Invalid return_type: {return_type}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"reference/pdag/#pdag.sample_parameter_values","title":"sample_parameter_values","text":"<pre><code>sample_parameter_values(\n    input_parameters: dict[ParameterId, ParameterABC[Any]],\n    n_samples: int,\n    *,\n    rng: Generator | None = None,\n) -&gt; list[dict[ParameterId, Any]]\n</code></pre> Source code in <code>src/pdag/_experiment/cases.py</code> <pre><code>def sample_parameter_values(\n    input_parameters: dict[ParameterId, ParameterABC[Any]],\n    n_samples: int,\n    *,\n    rng: np.random.Generator | None = None,\n) -&gt; list[dict[ParameterId, Any]]:\n    unit_samples_cases = latin_hypercube_sampling(n_samples, len(input_parameters), rng=rng)\n    return [\n        {\n            parameter_id: parameter.from_unit_interval(float(x))\n            for (parameter_id, parameter), x in zip(input_parameters.items(), unit_samples, strict=True)\n        }\n        for unit_samples in unit_samples_cases\n    ]\n</code></pre>"},{"location":"reference/pdag/#pdag.export_dot","title":"export_dot","text":"<pre><code>export_dot(core_model: CoreModel, path: Path) -&gt; None\n</code></pre> Source code in <code>src/pdag/_export/dot.py</code> <pre><code>def export_dot(core_model: CoreModel, path: Path) -&gt; None:\n    graph = to_dot_graph(core_model)\n    graph.write(str(path), format=\"png\")\n</code></pre>"},{"location":"reference/pdag/#pdag.Model","title":"Model","text":"<p>               Bases: <code>MultiDef</code></p> METHOD DESCRIPTION <code>parameters</code> <code>collections</code> <code>relationships</code> <code>to_core_model</code> <code>to_relationship</code> ATTRIBUTE DESCRIPTION <code>name</code> <p> TYPE: <code>str</code> </p> <code>__pdag_parameters__</code> <p> TYPE: <code>dict[str, ParameterABC[Any]]</code> </p> <code>__pdag_relationships__</code> <p> TYPE: <code>dict[str, RelationshipABC]</code> </p> <code>__pdag_collections__</code> <p> TYPE: <code>dict[str, CollectionABC[Any, Any]]</code> </p>"},{"location":"reference/pdag/#pdag.Model.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.__pdag_parameters__","title":"__pdag_parameters__  <code>instance-attribute</code>","text":"<pre><code>__pdag_parameters__: dict[str, ParameterABC[Any]]\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.__pdag_relationships__","title":"__pdag_relationships__  <code>instance-attribute</code>","text":"<pre><code>__pdag_relationships__: dict[str, RelationshipABC]\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.__pdag_collections__","title":"__pdag_collections__  <code>instance-attribute</code>","text":"<pre><code>__pdag_collections__: dict[str, CollectionABC[Any, Any]]\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.parameters","title":"parameters  <code>classmethod</code>","text":"<pre><code>parameters() -&gt; dict[str, ParameterABC[Any]]\n</code></pre> Source code in <code>src/pdag/_notation/model.py</code> <pre><code>@classmethod\ndef parameters(cls) -&gt; dict[str, ParameterABC[Any]]:\n    return cls.__pdag_parameters__\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.collections","title":"collections  <code>classmethod</code>","text":"<pre><code>collections() -&gt; dict[str, CollectionABC[Any, Any]]\n</code></pre> Source code in <code>src/pdag/_notation/model.py</code> <pre><code>@classmethod\ndef collections(cls) -&gt; dict[str, CollectionABC[Any, Any]]:\n    return cls.__pdag_collections__\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.relationships","title":"relationships  <code>classmethod</code>","text":"<pre><code>relationships() -&gt; dict[str, RelationshipABC]\n</code></pre> Source code in <code>src/pdag/_notation/model.py</code> <pre><code>@classmethod\ndef relationships(cls) -&gt; dict[str, RelationshipABC]:\n    return cls.__pdag_relationships__\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.to_core_model","title":"to_core_model  <code>classmethod</code>","text":"<pre><code>to_core_model() -&gt; CoreModel\n</code></pre> Source code in <code>src/pdag/_notation/model.py</code> <pre><code>@classmethod\ndef to_core_model(cls) -&gt; CoreModel:\n    return CoreModel(\n        name=cls.__name__,\n        parameters=cls.parameters(),\n        collections=cls.collections(),\n        relationships=cls.relationships(),\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.Model.to_relationship","title":"to_relationship  <code>classmethod</code>","text":"<pre><code>to_relationship(\n    name: str | EllipsisType,\n    *,\n    inputs: Mapping[ReferenceABC, ReferenceABC],\n    outputs: Mapping[ReferenceABC, ReferenceABC],\n    at_each_time_step: bool = False,\n) -&gt; SubModelRelationship\n</code></pre> Source code in <code>src/pdag/_notation/model.py</code> <pre><code>@classmethod\ndef to_relationship(\n    cls,\n    /,\n    name: str | EllipsisType,\n    *,\n    inputs: MappingABC[ReferenceABC, ReferenceABC],\n    outputs: MappingABC[ReferenceABC, ReferenceABC],\n    at_each_time_step: bool = False,\n) -&gt; SubModelRelationship:\n    return SubModelRelationship(\n        _name=name,\n        submodel_name=cls.name,\n        inputs=dict(inputs),\n        outputs=dict(outputs),\n        _submodel=cls.to_core_model(),\n        at_each_time_step=at_each_time_step,\n    )\n</code></pre>"},{"location":"reference/pdag/#pdag.relationship","title":"relationship","text":"<pre><code>relationship(\n    func: Callable[P, T],\n    *,\n    identifier: None = None,\n    at_each_time_step: Literal[False] = False,\n) -&gt; FunctionRelationship[P, T]\n</code></pre><pre><code>relationship(\n    func: None = None,\n    *,\n    identifier: Hashable = None,\n    at_each_time_step: bool = False,\n) -&gt; Callable[\n    [Callable[P, T]], FunctionRelationship[P, T]\n]\n</code></pre> <pre><code>relationship(\n    func: Callable[P, T] | None = None,\n    *,\n    identifier: Hashable = None,\n    at_each_time_step: bool = False,\n) -&gt; (\n    FunctionRelationship[P, T]\n    | Callable[\n        [Callable[P, T]], FunctionRelationship[P, T]\n    ]\n    | Callable[\n        [Callable[P, T]],\n        MultiDefProtocol[\n            Hashable, FunctionRelationship[P, T]\n        ],\n    ]\n)\n</code></pre> <p>Decorate a function to mark it as a relationship.</p> Source code in <code>src/pdag/_notation/decorators.py</code> <pre><code>def relationship[**P, T](\n    func: Callable[P, T] | None = None,\n    *,\n    identifier: Hashable = None,\n    at_each_time_step: bool = False,\n) -&gt; (\n    FunctionRelationship[P, T]\n    | Callable[[Callable[P, T]], FunctionRelationship[P, T]]\n    | Callable[[Callable[P, T]], MultiDefProtocol[Hashable, FunctionRelationship[P, T]]]\n):\n    \"\"\"Decorate a function to mark it as a relationship.\"\"\"\n\n    def decorator(\n        func: Callable[P, T],\n        *,\n        _relationship_name: str | EllipsisType | None = None,\n    ) -&gt; FunctionRelationship[P, T]:\n        # Get the function's signature\n        sig = inspect.signature(func)\n        inputs = _get_inputs_from_signature(sig)\n        outputs, output_is_scalar = _get_outputs_from_signature(sig)\n        function_body = get_function_body(func)\n        return FunctionRelationship(\n            _name=func.__name__ if _relationship_name is None else _relationship_name,\n            inputs=inputs,\n            outputs=outputs,\n            function_body=function_body,\n            output_is_scalar=output_is_scalar,\n            _function=func,\n            at_each_time_step=at_each_time_step,\n        )\n\n    if func is not None:\n        # If the decorator is used without parentheses, we need to return the decorator\n        return decorator(func)\n\n    if identifier is None:\n        return decorator\n\n    # If the identifier is provided, we need to return decorator to return multidef\n\n    def decorator_for_multidef(\n        func: Callable[P, T],\n    ) -&gt; MultiDefProtocol[Hashable, FunctionRelationship[P, T]]:\n        return multidef(identifier)(decorator(func, _relationship_name=...))\n\n    return decorator_for_multidef\n</code></pre>"},{"location":"reference/pdag/examples/","title":"examples","text":""},{"location":"reference/pdag/examples/#pdag.examples","title":"pdag.examples","text":"<p>Examples module that contains example models.</p> <p>Warning</p> <p>The examples are not intended to be used in production code and are provided for demonstration purposes only.</p> CLASS DESCRIPTION <code>DiamondMdpModel</code> <p>Diamond MDP model.</p> <code>EachSquaredModel</code> <p>EachSquaredModel model that uses a mapping of parameters.</p> <code>PolynomialModel</code> <p>Polynomial model to demonstrate how to include a model in another model.</p> <code>SquareModel</code> <p>Square model that squares a number.</p> <code>TwoSquares</code> <p>TwoSquares model to demonstrate mapping containing submodels.</p> <code>UmbrellaModel</code> <p>Evaluate which type of umbrella to take or not.</p>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel","title":"DiamondMdpModel","text":"<p>               Bases: <code>Model</code></p> <p>Diamond MDP model.</p> METHOD DESCRIPTION <code>action_selection</code> <code>state_transition</code> <code>initial_reward</code> <code>reward_function</code> <code>cumulative_reward_calculation</code> ATTRIBUTE DESCRIPTION <code>policy</code> <p> </p> <code>location</code> <p> </p> <code>action</code> <p> </p> <code>reward</code> <p> </p> <code>cumulative_reward</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.policy","title":"policy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>policy = CategoricalParameter(\n    \"policy\", categories=(\"left\", \"right\")\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location = CategoricalParameter(\n    \"location\",\n    categories=(\"start\", \"left\", \"right\", \"end\"),\n    is_time_series=True,\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.action","title":"action  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>action = CategoricalParameter(\n    \"action\",\n    categories=(\n        \"go_left\",\n        \"go_right\",\n        \"move_forward\",\n        \"none\",\n    ),\n    is_time_series=True,\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.reward","title":"reward  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reward = RealParameter('reward', is_time_series=True)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.cumulative_reward","title":"cumulative_reward  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cumulative_reward = RealParameter('cumulative_reward')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.action_selection","title":"action_selection  <code>staticmethod</code>","text":"<pre><code>action_selection(\n    *,\n    policy: Literal[\"left\", \"right\"],\n    location: Literal[\"start\", \"left\", \"right\", \"end\"],\n) -&gt; Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"]\n</code></pre> Source code in <code>src/pdag/examples/_diamond_mdp.py</code> <pre><code>@pdag.relationship(at_each_time_step=True)\n@staticmethod\ndef action_selection(  # noqa: PLR0911\n    *,\n    policy: Annotated[Literal[\"left\", \"right\"], policy.ref()],\n    location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n) -&gt; Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()]:\n    match location, policy:\n        case \"start\", \"left\":\n            return \"go_left\"\n        case \"start\", \"right\":\n            return \"go_right\"\n        case \"left\", \"left\":\n            return \"move_forward\"\n        case \"left\", \"right\":\n            return \"go_right\"\n        case \"right\", \"right\":\n            return \"move_forward\"\n        case \"right\", \"left\":\n            return \"go_left\"\n        case \"end\", _:\n            return \"none\"\n\n    msg = f\"Invalid policy and location combination: {policy=}, {location=}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.state_transition","title":"state_transition  <code>staticmethod</code>","text":"<pre><code>state_transition(\n    *,\n    location: Literal[\"start\", \"left\", \"right\", \"end\"],\n    action: Literal[\n        \"go_left\", \"go_right\", \"move_forward\", \"none\"\n    ],\n) -&gt; Literal[\"start\", \"left\", \"right\", \"end\"]\n</code></pre> Source code in <code>src/pdag/examples/_diamond_mdp.py</code> <pre><code>@pdag.relationship(at_each_time_step=True)\n@staticmethod\ndef state_transition(  # noqa: C901, PLR0911\n    *,\n    location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n    action: Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()],\n) -&gt; Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref(next=True)]:\n    match location, action:\n        case \"start\", \"go_left\":\n            return \"left\"\n        case \"start\", \"go_right\":\n            return \"right\"\n        case \"start\", \"move_forward\":\n            return \"start\"\n        case \"left\", \"move_forward\":\n            return \"end\"\n        case \"left\", \"go_left\":\n            return \"left\"\n        case \"left\", \"go_right\":\n            return \"right\"\n        case \"right\", \"move_forward\":\n            return \"end\"\n        case \"right\", \"go_left\":\n            return \"left\"\n        case \"right\", \"go_right\":\n            return \"right\"\n        case _, \"none\":\n            return location\n        case \"end\", _:\n            return \"end\"\n\n    msg = f\"Invalid location and action combination: {location=}, {action=}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.initial_reward","title":"initial_reward  <code>staticmethod</code>","text":"<pre><code>initial_reward() -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_diamond_mdp.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef initial_reward() -&gt; Annotated[float, reward.ref(initial=True)]:\n    return 0.0\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.reward_function","title":"reward_function  <code>staticmethod</code>","text":"<pre><code>reward_function(\n    *,\n    previous_location: Literal[\n        \"start\", \"left\", \"right\", \"end\"\n    ],\n    action: Literal[\n        \"go_left\", \"go_right\", \"move_forward\", \"none\"\n    ],\n    location: Literal[\"start\", \"left\", \"right\", \"end\"],\n) -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_diamond_mdp.py</code> <pre><code>@pdag.relationship(at_each_time_step=True)\n@staticmethod\ndef reward_function(\n    *,\n    previous_location: Annotated[\n        Literal[\"start\", \"left\", \"right\", \"end\"],\n        location.ref(previous=True),\n    ],\n    action: Annotated[  # noqa: ARG004\n        Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"],\n        action.ref(previous=True),\n    ],\n    location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n) -&gt; Annotated[float, reward.ref()]:\n    if previous_location != \"end\" and location == \"end\":\n        return 1.0\n    return 0.0\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.DiamondMdpModel.cumulative_reward_calculation","title":"cumulative_reward_calculation  <code>staticmethod</code>","text":"<pre><code>cumulative_reward_calculation(\n    *, reward: list[float]\n) -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_diamond_mdp.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef cumulative_reward_calculation(\n    *,\n    reward: Annotated[list[float], reward.ref(all_time_steps=True)],\n) -&gt; Annotated[float, cumulative_reward.ref()]:\n    return sum(reward)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.EachSquaredModel","title":"EachSquaredModel","text":"<p>               Bases: <code>Model</code></p> <p>EachSquaredModel model that uses a mapping of parameters.</p> METHOD DESCRIPTION <code>square</code> ATTRIBUTE DESCRIPTION <code>m</code> <p> </p> <code>m_squared</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.EachSquaredModel.m","title":"m  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>m = Mapping(\n    \"m\", {k: RealParameter(...) for k in (\"a\", \"b\", \"c\")}\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.EachSquaredModel.m_squared","title":"m_squared  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>m_squared = Mapping(\n    \"m_squared\",\n    {k: RealParameter(...) for k in (\"a\", \"b\", \"c\")},\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.EachSquaredModel.square","title":"square  <code>staticmethod</code>","text":"<pre><code>square(m_arg: float) -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_each_squared.py</code> <pre><code>@pdag.relationship(identifier=k)\n@staticmethod\ndef square(\n    # The annotation `m.ref(k)` indicates that the value of `m[k]` will be provided\n    # when the model is executed.\n    m_arg: Annotated[float, m.ref(k)],\n    # The annotation `m_squared.ref(k)` indicates that the return value of the method\n    # will be assigned to `m_squared[k]` when the model is executed.\n) -&gt; Annotated[float, m_squared.ref(k)]:\n    return m_arg**2\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel","title":"PolynomialModel","text":"<p>               Bases: <code>Model</code></p> <p>Polynomial model to demonstrate how to include a model in another model.</p> <p>This model calculates a polynomial <code>y = a[0] + a[1] * x + a[2] * x^2</code> where a[0], a[1], and a[2] are coefficients of the polynomial.</p> METHOD DESCRIPTION <code>polynomial</code> ATTRIBUTE DESCRIPTION <code>a</code> <p> </p> <code>x</code> <p> </p> <code>x_squared</code> <p> </p> <code>y</code> <p> </p> <code>calc_square_term</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.a","title":"a  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>a = Array(\n    \"a\", array([RealParameter(...) for _ in range(3)])\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x = RealParameter('x')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.x_squared","title":"x_squared  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_squared = RealParameter('x_squared')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y = RealParameter('y')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.calc_square_term","title":"calc_square_term  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calc_square_term = to_relationship(\n    \"calc_square_term\",\n    inputs={ref(): ref()},\n    outputs={ref(): ref()},\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.PolynomialModel.polynomial","title":"polynomial  <code>staticmethod</code>","text":"<pre><code>polynomial(\n    *, a: list[float], x: float, x_squared: float\n) -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_polynomials.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef polynomial(\n    *,\n    a: Annotated[list[float], a.ref()],\n    x: Annotated[float, x.ref()],\n    x_squared: Annotated[float, x_squared.ref()],\n) -&gt; Annotated[float, y.ref()]:\n    return a[0] + a[1] * x + a[2] * x_squared\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.SquareModel","title":"SquareModel","text":"<p>               Bases: <code>Model</code></p> <p>Square model that squares a number.</p> METHOD DESCRIPTION <code>square</code> <p>Square the input value.</p> ATTRIBUTE DESCRIPTION <code>x</code> <p> </p> <code>y</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.SquareModel.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x = RealParameter('x')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.SquareModel.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y = RealParameter('y')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.SquareModel.square","title":"square  <code>staticmethod</code>","text":"<pre><code>square(x_arg: float) -&gt; float\n</code></pre> <p>Square the input value.</p> Source code in <code>src/pdag/examples/_square.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef square(\n    # The annotation `x.ref()` indicates that the value of `x` will be provided\n    # as the value of the `x_arg` parameter when the model is executed.\n    x_arg: Annotated[float, x.ref()],\n    # The annotation `y.ref()` indicates that the return value of the method\n    # will be assigned to the `y` parameter when the model is executed.\n) -&gt; Annotated[float, y.ref()]:\n    \"\"\"Square the input value.\"\"\"\n    return x_arg**2\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares","title":"TwoSquares","text":"<p>               Bases: <code>Model</code></p> <p>TwoSquares model to demonstrate mapping containing submodels.</p> <p>This model calculates <code>z = x^2 + y^2</code>.</p> METHOD DESCRIPTION <code>squares</code> ATTRIBUTE DESCRIPTION <code>x</code> <p> </p> <code>x_squared</code> <p> </p> <code>y</code> <p> </p> <code>y_squared</code> <p> </p> <code>z</code> <p> </p> <code>calc_square_term</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.x","title":"x  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x = RealParameter('x')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.x_squared","title":"x_squared  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>x_squared = RealParameter('x_squared')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.y","title":"y  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y = RealParameter('y')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.y_squared","title":"y_squared  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>y_squared = RealParameter('y_squared')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.z","title":"z  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>z = RealParameter('z')\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.calc_square_term","title":"calc_square_term  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>calc_square_term = Mapping(\n    \"calc_square_term\",\n    {\n        name: to_relationship(\n            ...,\n            inputs={ref(): ref()},\n            outputs={ref(): ref()},\n        )\n        for (input_param, output_param) in [\n            (x, x_squared),\n            (y, y_squared),\n        ]\n    },\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.TwoSquares.squares","title":"squares  <code>staticmethod</code>","text":"<pre><code>squares(*, x_squared: float, y_squared: float) -&gt; float\n</code></pre> Source code in <code>src/pdag/examples/_squares.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef squares(\n    *,\n    x_squared: Annotated[float, x_squared.ref()],\n    y_squared: Annotated[float, y_squared.ref()],\n) -&gt; Annotated[float, z.ref()]:\n    return x_squared + y_squared\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel","title":"UmbrellaModel","text":"<p>               Bases: <code>Model</code></p> <p>Evaluate which type of umbrella to take or not.</p> METHOD DESCRIPTION <code>calc_wetness</code> <p>Calculate the wetness based on the rain and policy.</p> <code>calc_portability</code> <p>Calculate the portability based on the policy.</p> ATTRIBUTE DESCRIPTION <code>rain_intensity</code> <p> </p> <code>policy</code> <p> </p> <code>wetness</code> <p> </p> <code>portability</code> <p> </p>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.rain_intensity","title":"rain_intensity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rain_intensity = RealParameter(\n    \"rain_intensity\",\n    metadata={\"XLRM\": \"X\"},\n    lower_bound=0.0,\n    upper_bound=1.0,\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.policy","title":"policy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>policy = CategoricalParameter(\n    \"policy\",\n    (\n        \"take_umbrella\",\n        \"take_travel_umbrella\",\n        \"no_umbrella\",\n    ),\n    metadata={\"XLRM\": \"L\"},\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.wetness","title":"wetness  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>wetness = RealParameter('wetness', metadata={'XLRM': 'M'})\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.portability","title":"portability  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>portability = RealParameter(\n    \"portability\", metadata={\"XLRM\": \"M\"}\n)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.calc_wetness","title":"calc_wetness  <code>staticmethod</code>","text":"<pre><code>calc_wetness(rain_intensity: float, policy: str) -&gt; float\n</code></pre> <p>Calculate the wetness based on the rain and policy.</p> Source code in <code>src/pdag/examples/_umbrella.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef calc_wetness(\n    rain_intensity: Annotated[float, rain_intensity.ref()],\n    policy: Annotated[str, policy.ref()],\n) -&gt; Annotated[float, wetness.ref()]:\n    \"\"\"Calculate the wetness based on the rain and policy.\"\"\"\n    match policy:\n        case \"take_umbrella\":\n            return rain_intensity * 0.1\n        case \"take_travel_umbrella\":\n            return rain_intensity * 0.2\n        case \"no_umbrella\":\n            return rain_intensity\n        case _:\n            msg = f\"Unknown policy: {policy}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"reference/pdag/examples/#pdag.examples.UmbrellaModel.calc_portability","title":"calc_portability  <code>staticmethod</code>","text":"<pre><code>calc_portability(policy: str) -&gt; float\n</code></pre> <p>Calculate the portability based on the policy.</p> Source code in <code>src/pdag/examples/_umbrella.py</code> <pre><code>@pdag.relationship\n@staticmethod\ndef calc_portability(\n    policy: Annotated[str, policy.ref()],\n) -&gt; Annotated[float, portability.ref()]:\n    \"\"\"Calculate the portability based on the policy.\"\"\"\n    match policy:\n        case \"take_umbrella\":\n            return -1.0\n        case \"take_travel_umbrella\":\n            return -0.5\n        case \"no_umbrella\":\n            return 0.0\n        case _:\n            msg = f\"Unknown policy: {policy}\"\n            raise ValueError(msg)\n</code></pre>"}]}