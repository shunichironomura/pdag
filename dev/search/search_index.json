{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>pdag</code> \u2014 Parameter Directed Acyclic Graph","text":"<p>Warning</p> <p>This package is under development. Many features are already implemented, but expect some breaking changes in the future.</p> <p>Documentation: https://shunichironomura.github.io/pdag/</p> <p>Source code: https://github.com/shunichironomura/pdag</p> <p><code>pdag</code> helps you create and execute a directed acyclic graph (DAG) of parameters and their relationships. Its features include:</p> <ul> <li>You can define parameters and their dependencies with a Python's class-based syntax and annotations.</li> <li>You can import another model into your model, allowing you to create a hierarchy of models and reuse them.</li> <li>You can use the <code>pdag watch</code> command to watch the graph representation of your model while you are creating it.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pdag\n</code></pre> <p>or any package manager that supports Python packages.</p>"},{"location":"#basic-usage","title":"Basic usage","text":"<p>Here is a simple example of how to use <code>pdag</code> to create a model that squares a number:</p> <pre><code>from typing import Annotated\nimport pdag\n\nclass SquareModel(pdag.Model):\n    \"\"\"Square model that squares a number.\"\"\"\n\n    # x is a real number parameter and is the input to the model\n    x = pdag.RealParameter(\"x\")\n\n    # y is a real number parameter and is the output of the model\n    y = pdag.RealParameter(\"y\")\n\n    # The relationship is defined as a static method\n    # with the @pdag.relationship decorator\n    @pdag.relationship\n    @staticmethod\n    def square(\n      # The annotation `x.ref()` indicates that the value of `x` will be provided\n      # as the value of the `x_arg` parameter when the model is executed.\n      # Note that we use `x_arg` as the name of the argument for documentation purposes,\n      # but in practice, you can just use `x` as the name of the argument.\n      x_arg: Annotated[float, x.ref()],\n\n      # The annotation `y.ref()` indicates that the return value of the method\n      # will be assigned to the `y` parameter when the model is executed.\n    ) -&gt; Annotated[float, y.ref()]:\n        return x_arg**2\n</code></pre> <p>This <code>SquareModel</code> is a static model with input <code>x</code> and output <code>y</code>. Here is the graph representation of the model:</p> <p></p> <p>You can test it by running the following command in the virtual environment where you installed <code>pdag</code>:</p> <pre><code>pdag watch pdag.examples.square:SquareModel square.png\n</code></pre> <p>To execute the model for a specific value of <code>x</code>, execute the following code:</p> <pre><code>core_model = SquareModel.to_core_model()\nexec_model = pdag.create_exec_model_from_core_model(core_model)\nresults = pdag.execute_exec_model(\n    exec_model,\n    inputs={\n        # `()` indicates the root model, and `\"x\"` is the name of the parameter.\n        pdag.StaticParameterId((), \"x\"): 2.0,\n    },\n)\n\nprint(results)\n# {\n#   StaticParameterId(model_path=(), name='x'): 2.0,\n#   StaticParameterId(model_path=(), name='y'): 4.0,\n# }\n</code></pre>"},{"location":"#parameter-and-collection-types","title":"Parameter and collection types","text":"<p><code>pdag</code> supports the following parameter types:</p> <ul> <li><code>pdag.RealParameter</code>: A real number parameter.</li> <li><code>pdag.BooleanParameter</code>: A boolean parameter.</li> <li><code>pdag.CategoricalParameter</code>: A categorical parameter.</li> </ul> <p>and the following parameter collection types:</p> <ul> <li><code>pdag.Array</code>: An array of <code>pdag</code> parameters.</li> <li><code>pdag.Mapping</code>: A dictionary of <code>pdag</code> parameters.</li> </ul> <p>Here is an example of how to use these parameter types and collections:</p> <pre><code>from typing import Annotated\nimport numpy as np\nimport pdag\n\nclass ModelWithVariousTypes(pdag.Model):\n    \"\"\"Model that uses different parameter types and collections.\"\"\"\n\n    # x is a real number parameter\n    x = pdag.RealParameter(\"x\")\n\n    # y is a boolean parameter\n    y = pdag.BooleanParameter(\"y\")\n\n    # z is a categorical parameter with three possible values\n    z = pdag.CategoricalParameter(\"z\", (\"a\", \"b\", \"c\"))\n\n    # a is an array of real number parameters with two elements\n    # Each parameter's name is automatically generated as \"a[0]\" and \"a[1]\"\n    a = pdag.Array(\"a\", np.array([pdag.RealParameter(...) for _ in range(2)]))\n\n    # m is a dictionary of real number parameters\n    # Each parameter's name is automatically generated as \"m[a]\", \"m[b]\", and \"m[c]\"\n    m = pdag.Mapping(\"m\", {k: pdag.RealParameter(...) for k in [\"a\", \"b\", \"c\"]})\n\n    @pdag.relationship\n    @staticmethod\n    def my_relationship(\n        y_arg: Annotated[bool, y.ref()],\n        z_arg: Annotated[str, z.ref()],\n        a_arg: Annotated[list[float], a.ref()],\n        m_arg: Annotated[Mapping[str, float], m.ref()],\n    ) -&gt; Annotated[float, x.ref()]:\n        if y_arg:\n            return m_arg[z_arg] * a_arg[1] + a_arg[0]\n        else:\n            return 0.0\n</code></pre>"},{"location":"#define-relationships-in-a-for-loop","title":"Define relationships in a for loop","text":"<p><code>pdag</code> allows you to define relationships in a for loop. This is useful, for example, when you want to define a relationship for each element of a mapping.</p> <p>In the following example, we define a <code>EachSquaredModel</code> that calculates the square of each element of a mapping <code>m</code>:</p> <pre><code>from typing import Annotated\nimport numpy as np\nimport pdag\n\nclass EachSquaredModel(pdag.Model):\n    \"\"\"EachSquaredModel model that uses a mapping of parameters.\"\"\"\n\n    m = pdag.Mapping(\"m\", {k: pdag.RealParameter(...) for k in (\"a\", \"b\", \"c\")})\n    m_squared = pdag.Mapping(\"m_squared\", {k: pdag.RealParameter(...) for k in (\"a\", \"b\", \"c\")})\n\n    for k in (\"a\", \"b\", \"c\"):\n        # You need to provide the identifier to distinguish each relationship\n        @pdag.relationship(identifier=k)\n        @staticmethod\n        def square(\n            # The annotation `m.ref(k)` indicates that the value of `m[k]` will be provided\n            # when the model is executed.\n            m_arg: Annotated[float, m.ref(k)],\n\n            # The annotation `m_squared.ref(k)` indicates that the return value of the method\n            # will be assigned to `m_squared[k]` when the model is executed.\n        ) -&gt; Annotated[float, m_squared.ref(k)]:\n            return m_arg**2\n</code></pre>"},{"location":"#dynamic-models","title":"Dynamic models","text":"<p><code>pdag</code> supports dynamic models, where you can define time-series parameters and dynamic relationships between them.</p> <p>In the following example, we define a <code>DiamondMdpModel</code> that simulates a Markov Decision Process (MDP) with a diamond-shaped state space:</p> <pre><code>from typing import Annotated, Literal\n\nimport pdag\n\n\nclass DiamondMdpModel(pdag.Model):\n    \"\"\"Diamond MDP model.\"\"\"\n\n    # The policy parameter is the policy of the agent,\n    # and it is a categorical parameter with two possible values.\n    # It is NOT a time-series parameter.\n    policy = pdag.CategoricalParameter(\"policy\", categories=(\"left\", \"right\"))\n\n    # The location parameter is the state of the MDP.\n    # You need to provide the `is_time_series=True` argument\n    # to indicate that this parameter is a time-series parameter.\n    location = pdag.CategoricalParameter(\n        \"location\",\n        categories=(\"start\", \"left\", \"right\", \"end\"),\n        is_time_series=True\n    )\n\n    # The action parameter is the action taken by the agent,\n    # and it is also a time-series parameter.\n    action = pdag.CategoricalParameter(\n        \"action\",\n        categories=(\"go_left\", \"go_right\", \"move_forward\", \"none\"),\n        is_time_series=True,\n    )\n\n    # The reward parameter is the reward received by the agent,\n    # and it is also a time-series parameter.\n    reward = pdag.RealParameter(\"reward\", is_time_series=True)\n\n    # The cumulative_reward parameter is the cumulative reward received by the agent,\n    # and it is NOT a time-series parameter.\n    cumulative_reward = pdag.RealParameter(\"cumulative_reward\")\n\n    # For relationsihps that should be calculated at each time step,\n    # you need to provide the `at_each_time_step=True` argument\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def action_selection(\n        *,\n        # The value of `policy` is provided as the value of the `policy` parameter\n        policy: Annotated[Literal[\"left\", \"right\"], policy.ref()],\n\n        # The value of `location` at the current time step is provided as the value of the `location` parameter\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n\n        # The return value of the method is assigned to the `action` parameter\n        # at the current time step.\n    ) -&gt; Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()]:\n        match location, policy:\n            case \"start\", \"left\":\n                return \"go_left\"\n            case \"start\", \"right\":\n                return \"go_right\"\n            case \"left\", \"left\":\n                return \"move_forward\"\n            case \"left\", \"right\":\n                return \"go_right\"\n            case \"right\", \"right\":\n                return \"move_forward\"\n            case \"right\", \"left\":\n                return \"go_left\"\n            case \"end\", _:\n                return \"none\"\n\n        msg = f\"Invalid policy and location combination: {policy=}, {location=}\"\n        raise ValueError(msg)\n\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def state_transition(\n        *,\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n        action: Annotated[Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"], action.ref()],\n\n        # By providing `next=True`, you can indicate that the return value of the method\n        # will be assigned to the `location` parameter at the next time step.\n    ) -&gt; Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref(next=True)]:\n        match location, action:\n            case \"start\", \"go_left\":\n                return \"left\"\n            case \"start\", \"go_right\":\n                return \"right\"\n            case \"start\", \"move_forward\":\n                return \"start\"\n            case \"left\", \"move_forward\":\n                return \"end\"\n            case \"left\", \"go_left\":\n                return \"left\"\n            case \"left\", \"go_right\":\n                return \"right\"\n            case \"right\", \"move_forward\":\n                return \"end\"\n            case \"right\", \"go_left\":\n                return \"left\"\n            case \"right\", \"go_right\":\n                return \"right\"\n            case _, \"none\":\n                return location\n            case \"end\", _:\n                return \"end\"\n\n        msg = f\"Invalid location and action combination: {location=}, {action=}\"\n        raise ValueError(msg)\n\n    @pdag.relationship\n    @staticmethod\n    def initial_reward(\n      # By providing `initial=True`, you can indicate that the return value of the method\n      # will be assigned to the `reward` parameter at the initial time step.\n    ) -&gt; Annotated[float, reward.ref(initial=True)]:\n        return 0.0\n\n    @pdag.relationship(at_each_time_step=True)\n    @staticmethod\n    def reward_function(\n        *,\n        previous_location: Annotated[\n            Literal[\"start\", \"left\", \"right\", \"end\"],\n            # `previous=True` indicates that the value of the `location` parameter\n            # at the previous time step will be provided as the value of the `previous_location` parameter.\n            location.ref(previous=True),\n        ],\n        action: Annotated[\n            Literal[\"go_left\", \"go_right\", \"move_forward\", \"none\"],\n            # `previous=True` indicates that the value of the `action` parameter\n            # at the previous time step will be provided as the value of the `action` parameter.\n            action.ref(previous=True),\n        ],\n        location: Annotated[Literal[\"start\", \"left\", \"right\", \"end\"], location.ref()],\n    ) -&gt; Annotated[float, reward.ref()]:\n        if previous_location != \"end\" and location == \"end\":\n            return 1.0\n        return 0.0\n\n    @pdag.relationship\n    @staticmethod\n    def cumulative_reward_calculation(\n        *,\n        # `all_time_steps=True` indicates that the value of the `reward` parameter\n        # at all time steps will be provided as the value of the `reward` parameter.\n        reward: Annotated[list[float], reward.ref(all_time_steps=True)],\n    ) -&gt; Annotated[float, cumulative_reward.ref()]:\n        return sum(reward)\n</code></pre>"},{"location":"#importing-models","title":"Importing models","text":"<p><code>pdag</code> allows you to import another model into your model.</p> <p>In the following example, we define a <code>SquareModel</code> that squares a number and a <code>PolynomialModel</code> that uses the <code>SquareModel</code> to calculate the square term of a polynomial:</p> <pre><code>from typing import Annotated\nimport pdag\n\nclass SquareModel(pdag.Model):\n    \"\"\"Square model that squares a number.\"\"\"\n\n    x = pdag.RealParameter(\"x\")\n    y = pdag.RealParameter(\"y\")\n\n    @pdag.relationship\n    @staticmethod\n    def square(\n      x_arg: Annotated[float, x.ref()],\n    ) -&gt; Annotated[float, y.ref()]:\n        return x_arg**2\n\nclass PolynomialModel(pdag.Model):\n    \"\"\"Polynomial model that calculates y = a[0] + a[1] * x + a[2] * x^2.\"\"\"\n\n    a = pdag.Array(\"a\", np.array([pdag.RealParameter(...) for _ in range(3)]))\n    x = pdag.RealParameter(\"x\")\n    x_squared = pdag.RealParameter(\"x_squared\")\n    y = pdag.RealParameter(\"y\")\n\n    # Import the SquareModel into this model\n    calc_square_term = SquareModel.to_relationship(\n        \"calc_square_term\",\n        # Map the parameters of the SquareModel to the parameters of this model\n        # for inputs and outputs\n        inputs={SquareModel.x.ref(): x.ref()},\n        outputs={SquareModel.y.ref(): x_squared.ref()},\n    )\n\n    @pdag.relationship\n    @staticmethod\n    def polynomial(\n        *,\n        a: Annotated[list[float], a.ref()],\n        x: Annotated[float, x.ref()],\n        x_squared: Annotated[float, x_squared.ref()],\n    ) -&gt; Annotated[float, y.ref()]:\n        return a[0] + a[1] * x + a[2] * x_squared\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>Run tests with:</p> <pre><code>dotenvx run -f .env.pytest -- uv run pytest tests\n</code></pre> <p>or simply</p> <pre><code>PYTHONHASHSEED=0 uv run pytest tests\n</code></pre>"}]}